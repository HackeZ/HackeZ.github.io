<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.18" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> HackerZ - Blog &middot; HackerZ - Blog </title>

  
  <link rel="stylesheet" href="http://hackez.github.io/css/poole.css">
  <link rel="stylesheet" href="http://hackez.github.io/css/syntax.css">
  <link rel="stylesheet" href="http://hackez.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.useso.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/languages/go.min.js"></script>
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/monokai_sublime.min.css">
  
  <script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
    <link href="http://hackez.github.io/index.xml" rel="alternate" type="application/rss+xml" title="HackerZ - Blog" />
  

  
  
  <script type="text/javascript"> 
  var sc_project=10940566; 
  var sc_invisible=0; 
  var sc_security="89189822"; 
  var scJsHost = (("https:" == document.location.protocol) ?
  "https://secure." : "http://www.");
  document.write("<sc"+"ript type='text/javascript' src='" +
  scJsHost+
  "statcounter.com/counter/counter.js'></"+"script>");
  </script>
  <noscript><div class="statcounter"><a title="web stats"
  href="http://statcounter.com/free-web-stats/"
  target="_blank"><img class="statcounter"
  src="//c.statcounter.com/10940566/0/89189822/0/" alt="web
  stats"></a></div></noscript>
  
</head>

<body class="theme-base-08 ">

<div class="sidebar">
  <div class="container sidebar-sticky">
  <div class="round-head">
    <img style="margin: auto;" src="http://hackez.github.io/author-head.png" alt="">
    <p style="text-align: center;"></p>
  </div>

    <div class="sidebar-about">
      <a href="http://hackez.github.io/"><h1>HackerZ - Blog</h1></a>
      <p class="lead">
       Welcome to my personal Blog 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
        <li><a href="/welcome/"> Welcome </a></li>
      
        <li><a href="/booklist"> Book List </a></li>
      
    </ul>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/go-sql-driver-source-code/">
        go-sql-deiver 源码解析
      </a>
    </h1>

    <span class="post-date">Sun, Oct 15, 2017</span>

    

<h2 id="intro">Intro</h2>

<p>最近正在给 <code>mysql</code> 封装一个库，顺带研究一下 <code>go-mysql-driver</code> 这个库的源码实现。</p>

<h2 id="buffer-go">Buffer.go</h2>

<p><code>buffer</code> 是一个用于给 <strong>数据库连接</strong> (<code>net.Conn</code>) 进行缓冲的一个数据结构，其结构为：</p>

<pre><code class="language-go">type buffer struct {
    buf 	[]byte     // 缓冲池中的数据
  	nc  	net.Conn   // 负责缓冲的数据库连接对象
  	idx 	int		   // 已读数据索引
    length 	int        // 缓冲池中未读数据的长度
   	timeout time.Duration // 数据库连接的超时设置
}
</code></pre>

<p>可以看到，因为  <strong>数据库连接</strong> (<code>net.Conn</code>)  在通信的时候是 <strong>同步</strong> 的。而为了让其能够 <strong>同时 读/写</strong> ，所以实现了 <code>buffer</code> 这个数据结构，通过该 <code>buffer</code> 进行数据缓冲还能实现 <strong>零拷贝</strong> ( <a href="https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%A4%8D%E5%88%B6">zero-copy-ish</a> ) 。</p>

<p>其函数分别有：</p>

<h4 id="newbuffer-nc-net-conn-buffer"><code>newBuffer(nc net.Conn) buffer</code></h4>

<p>创建并返回一个 <code>buffer</code></p>

<h4 id="buffer-readnext-need-int-byte-error"><code>(*buffer) readNext(need int) ([]byte, error)</code></h4>

<p>读取并返回未读数据的 <strong>need</strong> 位，如果 <strong>need</strong> 大于 <code>buffer</code> 的 <code>length</code> ，就会调用 <code>fill(need int) error</code> 对 <code>buffer</code>进行 <strong>扩容</strong> 。</p>

<h4 id="buffer-fill-need-int-error">(*buffer) fill(need int) error`</h4>

<p>对 <code>buffer</code> 进行 <code>(need/defaultBufSize)</code> 的倍数扩容，并在 <code>timeout</code> 时间结束前从 <code>buffer.nc</code> 中读取 <strong>need</strong> 长度的数据。</p>

<h4 id="buffer-takebuffer-length-int-byte"><code>(*buffer) takeBuffer(length int) []byte</code></h4>

<p>读取 <code>buffer</code> 中 <code>length</code> 长度的数据（只包含已读），如果 <code>buffer.length &gt; 0</code> ，即还有未读数据，则立即返回 <code>nil</code> 。</p>

<p>如果需要读取的长度大于 <code>buffer</code> 的容量，则会进行扩容。</p>

<h4 id="buffer-takesmallbuffer-length-int-byte"><code>(*buffer) takeSmallBuffer(length int) []byte</code></h4>

<p>读取保证不超过 <code>defaultBufSize</code> 长度的数据的快捷函数（只包含已读），如果 <code>buffer.length &gt; 0</code> ，即还有未读数据，则立即返回 <code>nil</code> 。</p>

<h4 id="buffer-takecompletebuffer-byte"><code>(*buffer) takeCompleteBuffer() []byte</code></h4>

<p>读取全部的 <code>buffer</code> 数据（只包含已读），如果 <code>buffer.length &gt; 0</code> ，即还有未读数据，则立即返回 <code>nil</code> 。</p>

<h2 id="collations-go">Collations.go</h2>

<p><code>collations</code> 包含了 <code>MySQL</code> 所有支持的 <strong>字符集</strong> 格式，并支持通过 <code>COLLATION_NAME</code> 返回其字符集 <code>ID</code>。</p>

<p>如果需要查询 <code>MySQL</code> 支持的 <strong>字符集</strong> 格式，可以使用 <code>SELECT COLLATION_NAME, ID FROM information_schema.COLLATIONS</code> 语句获取。</p>

<h2 id="dsn-go">Dsn.go</h2>

<p><code>DSN</code> 即 <strong>数据源名称 （Data Source Name）</strong>  ，是 <strong>驱动程序连接数据库的变量信息</strong> ，简而言之就是根据你连接的不同数据库使用对应的连接信息。</p>

<p>通常，数据库的连接配置就是在这里定义的：</p>

<pre><code class="language-go">// Config 基本的数据库连接信息
type Config struct {
	User         string            // Username
	Passwd       string            // Password (requires User)
	Net          string            // Network type
	Addr         string            // Network address (requires Net)
	DBName       string            // Database name
	Params       map[string]string // Connection parameters
	Collation    string            // Connection collation
	Loc          *time.Location    // Location for time.Time values
	TLSConfig    string            // TLS configuration name
	tls          *tls.Config       // TLS configuration
	Timeout      time.Duration     // Dial timeout
	ReadTimeout  time.Duration     // I/O read timeout
	WriteTimeout time.Duration     // I/O write timeout

	AllowAllFiles           bool // 允许文件使用 LOAD DATA LOCAL INFILE 导入数据库
	AllowCleartextPasswords bool // 支持明文密码客户端
	AllowOldPasswords       bool // 允许使用不可靠的旧密码
	ClientFoundRows         bool // 返回匹配的行数而不是受影响的行数
	ColumnsWithAlias        bool // 将表名前置在列名
	InterpolateParams       bool // 将占位符插入查询的SQL字符串
	MultiStatements         bool // 允许一条语句多次查询
	ParseTime               bool // 格式化时间值为 time.Time 变量
	Strict                  bool // 将 warnings 返回 errors
}
</code></pre>

<p>这都是一些常见的配置项，就此略过。</p>

<p>该文件有两个公共函数支持 <code>Config</code> 与 <code>DSN</code> 之间转换。</p>

<ul>
<li><code>(*Config)FormatDSN() string</code></li>
<li><code>ParseDSN(dsn string) (*Config, error)</code></li>
</ul>

<h2 id="errors-go">Errors.go</h2>

<p><code>errors</code> 定义了 <code>Logger</code> 、<code>MySQLError</code> 、 <code>MySQLWarning</code> 等数据结构。</p>

<h4 id="logger">Logger</h4>

<p>复用了 <code>Go</code> 原生的 <code>log</code> 包，并将其中的输出重定向至控制台的 <strong>标准错误</strong> 。</p>

<pre><code class="language-go">type Logger interface {
  Print(v ...interface{})
}

var errLog = Logger(log.New(os.Stderr, &quot;[mysql]&quot;, log.Ldate|log.Ltime|log.Lshortfile))

func SetLogger(logger Logger) error { // 当然，你也可以使用自定义的错误 Logger
  if logger == nil {
    return errors.New(&quot;logger is nil&quot;)
  }
  errLog =logger
  return nil
}
</code></pre>

<h4 id="mysqlerror">MySQLError</h4>

<p>而 <code>MySQLError</code> 则简单定义了 <code>MySQL</code> 输出的错误的结构。</p>

<pre><code class="language-go">type MySQLError struct {
	Number  uint16
	Message string
}
</code></pre>

<h4 id="mysqlwarning">MySQLWarning</h4>

<p><code>MySQLWarning</code> 则有些不一样，它需要从 <code>MySQL</code> 中进行一次 <strong>查询</strong> ，以获取所有的警告信息，所以该包也定义了 <code>MySQLWarning</code> 的 <code>slice</code> 结构。</p>

<pre><code class="language-go">type MySQLWarning struct {
    Level string
  	Code string
  	Message string
}

type MySQLWarnings []MySQLWarning

func (mc *mysqlConn) getWarnings() (err error) {
  rows, err := mc.Query(&quot;SHOW WARNINGS&quot;, nil)
  // handle err
  
  // initzation MySQLWarnings
  
  for {
    err = rows.Next(values)
    switch err {
      case nil:
      	warning := MySQLWarning{}
      	
      if raw, ok := values[0].([]byte); ok {
          warning.Level = string(raw)
      }else {
          warning.Level = fmt.Sprintf(&quot;%s&quot;, values[0])
      }
      
      if raw, ok := values[1].([]byte); ok {
        warning.Code = string(raw)
      } else {
        warning.Code = fmt.Sprintf(&quot;%s&quot;, values[1])
      }
      
      if raw, ok := values[2].([]byte); ok {
        warning.Message = string(raw)
      } else {
        warning.Message = fmt.Sprintf(&quot;%s&quot;, values[0])
      }

      warnings = append(warnings, warning)
    }
    
    case io.EOF:
    	return warnings
    
    default:
    	rows.Close() // 值得注意的是，如果该函数没有 case 运行 default ，该 rows 就不会被默认关闭，就会占用连接池中的一个连接，是否应该使用 `defer rows.Close() ` 避免该情况？
    	return
  }
}
</code></pre>

<h2 id="infile-go">Infile.go</h2>

<p>前面也有提到 <code>MySQL</code> 在导入大型文件的时候，需要使用 <code>LOAD DATA LOCAL INFILE</code> 的形式进行导入，而该 <code>infile.go</code> 就是实现该协议的代码。</p>

<p>本包在实现的 <code>LOAD DATA</code> 的时候提供了两种方式进行导入：</p>

<ul>
<li>最常见的，使用服务器的文件路径，如 <code>/data/students.csv</code> ，下文命名其为 <strong>文件路径注册器</strong></li>
<li>最通用的，使用实现了 <code>io.Reader</code> 接口的数据结构，通过返回该数据结构的数据进行导入，如 <code>bytes</code> <code>os.file</code> 等，下文命名其为 <strong>Reader 接口注册器</strong></li>
</ul>

<p>在实现该功能的时候，<strong>注册器</strong> 的实现是用名字作为 Key 的 <code>Map</code> ，为了避免 <code>Map</code> 的 <strong>读写竞态</strong> ，需要对其配置一个读写锁。</p>

<pre><code class="language-go">var (
	fileRegister	  	map[string]bool  	// 文件路径注册器
  	fileRegisterLock  	sync.RWMutex	   	// 文件路径注册器读写锁
	readerRegister	  	map[string]func() io.Reader // Reader 接口注册器
  	readerRegisterLock 	sync.RWMutex				// Reader 接口注册器读写锁	
)
</code></pre>

<p>除了对两个注册器的 <strong>注册</strong> 以及 <strong>注销</strong> 函数，还有一个需要分析的一个函数：</p>

<p><code>(mc *mysqlConn) handleInFileRequest(name string) (err error)</code></p>

<p>通过传入 <strong>文件路径</strong> 或者 <strong>Reader 名称</strong> 就可以将数据发往 <code>MySQL</code> 了。</p>

<pre><code class="language-go">func (mc *mysqlConn) handleInFileRequest(name string) (err error) {
    packSize := 16 * 1024 // 16KB is small enough for disk readahead and large enough for TCP
    if mc.maxWriteSize &lt; packSize { // 设置发往 MySQL 的数据块大小
        packSize = mc.maxWriteSize
  	}
  
  	// 获取 文件 或 Reader 的数据，并将其赋值到 rdr 中
  	// var rdr io.Reader
  
  	// send context packets
  	if err != nil {
      	data := make([]byte, 4+packetSize) // 需要留 4 个 byte 给协议使用
      	var n int
	    for err == nil {
          	n, err = rdr.Read(data[4:]) // 将数据存入 data 的 [4:] 中
          	if n &gt; 0 {
				if ioErr := mc.writePacket(data[:4+n]); ioErr != nil { // 将 data 数据发往 MySQL
					return ioErr
				}
			}
      	}
      	if err == io.EOF { // rdr 中的数据读完了
			err = nil
		}
  	}
  
  	// send empty packet (termination)
	if data == nil {
		data = make([]byte, 4)
	}
	if ioErr := mc.writePacket(data[:4]); ioErr != nil { // 告诉 MySQL 文件发送完毕
		return ioErr
	}

	// read OK packet
	if err == nil { // 一切正常结束
		return mc.readResultOK()
	}

	mc.readPacket() // 如果中途出错，将错误信息读取到 mysqlConn 中，并返回该错误
	return err
}
</code></pre>

<p>到此，<code>infile.go</code> 的实现已经整理完毕了，可以看到， 作者 在实现这个功能的时候还是做了一些优化的，比如 <code>map Lazy init</code> ，<code>send packet size limited</code> 等。而我们通过分析规范的源码包，能够提升自己的编码水平。</p>

<h2 id="packets-go">Packets.go</h2>

<p>接下来就要深入到 <code>MySQL</code> 的通信协议中了，官方的 <a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html">通信协议文档</a> 非常齐全，我在这里只将一些基础的，我后面分析源码会用到的协议分析下，如果有兴趣，可以到官方文档处进行查阅。</p>

<h3 id="protocol-basics">Protocol Basics</h3>

<h4 id="基础数据类型">基础数据类型</h4>

<p><code>MySQL</code> 通信的基本数据类型有两种， <code>Integer</code> 、 <code>String</code></p>

<ul>
<li>Integer : 分别有 <strong>1</strong>， <strong>2</strong>， <strong>3</strong>， <strong>4</strong>， <strong>8</strong> 个字节长度的类型，使用小端传输。</li>
<li>String : 分别有 <strong>固定长度字符串（协议规定）</strong>，<strong>NULL结尾字符串（长度不固定）</strong>，<strong>长度编码字符串（长度不固定）</strong>。</li>
</ul>

<h4 id="报文协议">报文协议</h4>

<p>报文分为 <strong>消息头</strong> 以及 <strong>消息体</strong>，而 <strong>消息头</strong> 由 3 字节的 <strong>消息长度</strong> 以及 1 字节的 <strong>序号</strong>  <code>sequence</code> （新客户端由 <code>0</code> 开始）组成，<strong>消息体</strong> 则由 <strong>消息长度</strong> 的字节组成。</p>

<ul>
<li>3 字节的 <strong>消息长度</strong> 最大值为 <code>0xFFFFFF</code> ，即为 <code>16 MB - 1 byte</code> ，这就意味着，如果整个消息（包括消息头）的长度大于 <code>16MB - 1byte - 4byte</code> 大小时，消息就会被分包。</li>
<li>1 字节的 <strong>序号</strong> 在每次新的客户端发起请求时，以 <code>0</code> 开始，依次递增 1 ，如果消息需要分包， <strong>序号</strong> 会随着分包的数量递增。而在一次应答中， 客户端会校验服务器 <strong>返回序号</strong> 是否与 <strong>发送序号</strong> 一致，如果不一致，则返回错误异常。</li>
</ul>

<h4 id="协议类型">协议类型</h4>

<ul>
<li><code>handshake</code> : 发起连接</li>
<li><code>auth</code> : 登录权限校验</li>
<li><code>ok | error</code> : 返回结果状态 <code>*</code>

<ul>
<li><code>ok</code> : 首字节为 0 （<code>0x00</code>）</li>
<li><code>error</code> : 首字节为 255 （<code>0xff</code>）</li>
</ul></li>
<li><code>resultset</code> : 结果集

<ul>
<li>header</li>
<li>field</li>
<li>eof</li>
<li>row</li>
</ul></li>
<li><code>command package</code> : 命令</li>
</ul>

<p>在整个 <code>MySQL</code> 发起交互的过程如下图所示：</p>

<p><img src="http://7xsxev.com1.z0.glb.clouddn.com/mysql%20%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="mysql connect" /></p>

<p>在了解这些 <code>MySQL</code> 基础协议知识后，我们再来看 <code>packages.go</code> 的源码就轻松多了。</p>

<h4 id="源码">源码</h4>

<p>先来看看 <code>readPacket</code> ，结合上面的知识点应该非常好理解。</p>

<pre><code class="language-go">func (mc *mysqlConn) readPacket() ([]byte, error) {
    var payload []byte
  	for { // for 循环是为了读取有可能分片的数据
     	// Read package header
      	data, err := mc.buf.readNext(4) // 从 buffer 缓冲器中读取 4 字节的 header
      	if err != nil { // 如果读取发生异常，则关闭连接，并返回一个错误连接的异常
          	errLog.Print(err)
          	mc.Close()
          	return nil, driver.ErrBadConn 
      	}
      
      	// Packet Length [24 bit]
      	pktLen := int(uint32(data[0]) | uint32(data[1])&lt;&lt;8 | uint32(data[2])&lt;&lt;16) // 读取 3 字节的消息长度
      
      	if pktLen &lt; 1 {
          	// 如上所示，关闭连接，并返回一个错误连接的异常
      	}
      
      	// Check Packet Sync [8 bit]
      	if data[3] != mc.sequence { // 判断服务端返回的序号是否与客户端一致
          	if data[3] &gt; mc.sequence {
             	return nil, ErrPktSyncMul // 如果服务端返回序号大于客户端的序号，则有可能是在一次请求中做了多次操作
          	}
          	return nil, ErrPktSync // 返回序号不一致错误
      	}
      	mc.sequence++ // 本次序号匹配相符，为了匹配下一次请求，先将序号自增1
      
      	data, err := mc.buf.readNext(pktLen) // 读取 消息长度 的数据
      	if err != nil {
          	// 如上所示，关闭连接，并返回一个错误连接的异常
      	}
      
      	isLastPacket := (pktLen &lt; maxPacketSize) // 如果是最后一个数据包，必然小于 maxPacketSize (16MB - 1byte)
      	
      	// Zero allocations for non-splitting packets
		if isLastPacket &amp;&amp; payload == nil { // 无分包情况，立即返回
			return data, nil
		}

		payload = append(payload, data...)

		if isLastPacket { // 如果是最后一个包，读取完毕后返回
			return payload, nil
		}
      
      	// 还有未读数据，开始下一次循环
  	}
}
</code></pre>

<p>下面来看下结合 <strong>握手报文协议</strong> 来看下客户端向服务端发起请求的 <code>readInitPacket</code> ：</p>

<p><img src="http://7xsxev.com1.z0.glb.clouddn.com/mysql_protocol_handshake.png" alt="mysql handshack protocol" /></p>

<pre><code class="language-go">func (mc *mysqlConn) readInitPacket() ([]byte, error) {
  	data, err := mc.readPacket() // 调用上面的函数读取服务端返回的数据
  	if err != nil {
      	return nil, err
  	}
  
  	if data[0] == iERR { // iERR = 0xff  消息体的第一个字节返回 0xff ，则意味着 error package
      	return nil, mc.handleErrorPacket(data)
  	}
  
  	// protocol version [1 byte]
  	if data[0] &lt; minProtocolVersion { // 判断是否是兼容的协议版本
      	return nil, fmt.Errorf(
			&quot;unsupported protocol version %d. Version %d or higher is required&quot;,
			data[0],
			minProtocolVersion,
		)
  	}
  
  	// server version [null terminated string]
	// connection id [4 bytes]
  	pos := 1 + bytes.IndexByte(data[1:], 0x00) + 1 + 4 // 读取 NULL （0x00）为结尾的字符串，跳过服务器线程 ID
  
  	// first part of the password cipher [8 bytes]
  	cipher := data[pos : pos+8] // 获取挑战随机数
  
  	// (filler) always 0x00 [1 byte]
	pos += 8 + 1
  
  	// capability flags (lower 2 bytes) [2 bytes]
	mc.flags = clientFlag(binary.LittleEndian.Uint16(data[pos : pos+2])) // 获取服务器权能标识
	if mc.flags&amp;clientProtocol41 == 0 { // 说明 MySQL 服务器不支持高于 41 版本的协议
		return nil, ErrOldProtocol
	}
	if mc.flags&amp;clientSSL == 0 &amp;&amp; mc.cfg.tls != nil { // 说明 MySQL 服务器需要 SSL 加密，但是客户端没有配置 SSL
		return nil, ErrNoTLS
	}
	pos += 2 // 指针向后两位
  
  	if len(data) &gt; pos {
      	// 指针跳过标志位
		pos += 1 + 2 + 2 + 1 + 10

		// second part of the password cipher [mininum 13 bytes],
		// where len=MAX(13, length of auth-plugin-data - 8)
		//
		// The web documentation is ambiguous about the length. However,
		// according to mysql-5.7/sql/auth/sql_authentication.cc line 538,
		// the 13th byte is &quot;\0 byte, terminating the second part of
		// a scramble&quot;. So the second part of the password cipher is
		// a NULL terminated string that's at least 13 bytes with the
		// last byte being NULL.
		//
		// The official Python library uses the fixed length 12
		// which seems to work but technically could have a hidden bug.
		cipher = append(cipher, data[pos:pos+12]...)

		// TODO: Verify string termination
		// EOF if version (&gt;= 5.5.7 and &lt; 5.5.10) or (&gt;= 5.6.0 and &lt; 5.6.2)
		// \NUL otherwise
		//
		//if data[len(data)-1] == 0 {
		//	return
		//}
		//return ErrMalformPkt

		// make a memory safe copy of the cipher slice
		var b [20]byte
		copy(b[:], cipher)
		return b[:], nil
	}

	// make a memory safe copy of the cipher slice
	var b [8]byte // 返回 8 字节的挑战随机数
	copy(b[:], cipher)
	return b[:], nil
}
</code></pre>

<p>除了上面解析的两个函数， <code>packages.go</code> 还有 <code>initialisation process</code> / <code>result packages</code> / <code>prepared statements</code> 等协议的 <strong>写入/读取</strong> ，有兴趣的读者可以结合上面的知识点自行阅读。</p>

<h2 id="driver-go">Driver.go</h2>

<p>接下来就要分析一些比较重要的代码了，比如接下来要讲的 <code>driver.go</code> ，它主要负责与 <code>MySQL</code> 数据库进行各种协议的连接，并返回该连接。可以说它才是最基础、最核心的功能。</p>

<p>不过首先我们需要看下 <code>database/sql</code> 包中的 <code>Driver</code> 接口需要如何实现：</p>

<pre><code class="language-go">// database/sql/driver/driver.go

// 数据库驱动
type Driver interface {
  Open(name string) (Conn, error)
}

// ...

// 非并发安全数据库连接
type Conn interface {
  // 返回一个绑定到 sql 的准备语句
  Prepare(query string) (Stmt, error)
  
  // 关闭该连接，并标记为不再使用，停止所有准备语句和事务
  // 因为 database/sql 包维护了一个空闲的连接池，并且在空闲连接过多的时候会自动调用 Close ，所以驱动程序包不需要显式调用该函数
  Close() error
  
  // 开始并返回一个新的事务，而新的事务与旧的连接没有任何关联
  Begin() (Tx, error)
}
</code></pre>

<p>根据 <code>database/sql</code> 提供的 <code>Driver</code> 接口， <code>go-sql-driver/mysql</code> 实现了自己的 <strong>数据库驱动</strong> 结构：</p>

<pre><code class="language-go">type MySQLDriver struct{}

func (d MySQLDriver) Open(dsn string) (driver.Conn, error) {
  mc := &amp;mysqlConn {
      // set max value
  }
  mc.cfg = ParseDSN(dsn) // 通过解析 DSN 设置 MySQL 连接的配置

  // set parseTime and strict
  // ...
  
  // connect to server
  if dial, ok := dials[mc.cfg.Net]; ok { // 根据 地址 以及 协议类型，尝试连接上服务器
    mc.netConn, err = dial(mc.cfg.Addr)
  } else { // 连接服务器失败，尝试重连
    nd := net.Dialer{Timeout: mc.cfg.Timeout}
    mc.netConn, err := nd.Dial(mc.cfg.Net, mc.cfg.Addr)
  }
  if err !=  nil { // 重试失败，返回异常
      return nil, err
  }
  
  // Enable TCP Keepalives on TCP connections
  if tc, ok := mc.netConn.(*net.Conn); ok { // tcp 连接类型转换
    if err := tc.SetKeepAlive(true); err != nil {
      // Don't send COM_QUIT before handshake.
      mc.netConn.Close() // 如果设置长连接失败，返回异常之前一定要记得将连接断开
      mc.netConn = nil
      return nil, err
    }
  }
  
  mc.buff = newBuff(mc.netConn) // 生成一个带缓冲的 buffer，如上面 buffer.go 中所说
  
  // set I/O timeout
  // ...
  
  // Reading Handshake Initialization Packet
  cipher, err := mc.readInitPacket() // 发起数据库首次握手
  if err != nil {
    mc.cleanup() // 将当前 mysqlConn 对象销毁，后面我们会说这个函数
    return nil, err
  }
  
  // Send Client Authentication Packet
  if err = mc.writeAuthPacket(cipher); err != nil { // 向数据库发送登录信息校验
    mc.cleanup()
    return nil, err
  }
}
</code></pre>

<h2 id="connection-go">connection.go</h2>

<p>终于要讲到这个包的核心数据结构 <code>mysqlConn</code> 了，可以说，驱动的所有功能几乎都围绕着这个数据结构，我们先来看看它的结构：</p>

<pre><code class="language-go">type mysqlConn struct {
    buf              buffer 	// buffer 缓冲器
	netConn          net.Conn	// 网络连接
	affectedRows     uint64		// sql 执行成功影响行数
	insertId         uint64		// sql 添加成功最新的主键 ID
	cfg              *Config	// dsn 中的 基础配置
  	maxPacketAllowed int		// 允许的最大报文的字节长度，最大不能超过 (16MB - 1byte)
	maxWriteSize     int		// 允许最大的写入字节长度，最大不能超过 (16MB - 1byte)
	writeTimeout     time.Duration 	// 执行 sql 的 超时时间
	flags            clientFlag		// 客户端状态标识
	status           statusFlag		// 服务端状态标识
	sequence         uint8			// 序号
	parseTime        bool			// 是否格式化时间
	strict           bool			// 是否使用严格模式
}

// driver.go
// 而创建一个 mysqlConn 连接需要通过 driver.go 中的 Open 函数，也说明 mysqlConn 实现了 driver.Conn 接口
func (d MySQLDriver) Open(dsn string) (driver.Conn, error) {
  mc := &amp;mysqlConn{
      // ...
  }
  
  // ...
  
  return mc, nil
}
</code></pre>

<p>当一个新的客户端连接上服务器的时候 （三次握手结束，客户端进入 <code>established</code> 状态），需要先对 <code>MySQL</code> 服务器进行 <strong>会话的用户/系统环境变量</strong> 的设置。</p>

<pre><code class="language-go">// Handles parameters set in DSN after the connection is established
func (mc *mysqlConn) handleParams() (err error) {
  	for param, val := range mc.cfg.Params { // Params: map[string]string
      	switch param {
        // Charset
        case &quot;charset&quot;: // 如果是字符集，则调用 SET NAMES 命令
          	charsets := strings.Split(val, &quot;,&quot;)
			for i := range charsets {
				// ignore errors here - a charset may not exist
				err = mc.exec(&quot;SET NAMES &quot; + charsets[i])
				if err == nil {
					break
				}
			}
			if err != nil {
				return
			}

		// System Vars
		default: // 执行系统环境变量设置
			err = mc.exec(&quot;SET &quot; + param + &quot;=&quot; + val + &quot;&quot;)
			if err != nil {
				return
			}
      	}
  	}
}
</code></pre>

<p><code>conntion.go</code>  还负责 <strong>事务</strong> 、<strong>预处理语句</strong> 、<strong>执行/查询</strong> 的管理，但是基本都是往 <code>mysqlConn</code> 中发送  <code>command package</code> ，如：</p>

<pre><code class="language-go">// Begin 开启事务
func (mc *mysqlConn) Begin() (driver.Tx, error) {
	if mc.netConn == nil {
		errLog.Print(ErrInvalidConn)
		return nil, driver.ErrBadConn
	}
	err := mc.exec(&quot;START TRANSACTION&quot;)
	if err == nil {
		return &amp;mysqlTx{mc}, err // 返回成功开启的事务，重用之前的连接
	}

	return nil, err
}

// Internal function to execute commands
func (mc *mysqlConn) exec(query string) error {
    // Send command
  	err := mc.writeCommandPacketStr(comQurey, query)
  	if err != nil {
		return err
	}
  
  	// Read Result
  	resLen, err := mc.readResultSetHeaderPacket() // 根据 data[0] 的值判断是否出错，如果没有错误，则返回消息体的长度
  	if err == nil &amp;&amp; resLen &gt; 0 { // 存在有效消息体
		if err = mc.readUntilEOF(); err != nil { // 读取 columns
			return err
		}

		err = mc.readUntilEOF() // 读取 rows
	}

	return err
}
</code></pre>

<p>我想 <code>conntion.go</code> 中最重要的一个函数应该是 <code>cleanup</code> ，它负责将 <strong>连接关闭</strong> 、 <strong>重置环境变量</strong> 等功能，但是该函数不能随意调用，它只有在 <strong>登录权限校验异常</strong> 时候才应该被调用，否则服务器在不知道客户端 <strong>被强行关闭</strong> 的情况下，依然会向该客户端发送消息，导致严重异常：</p>

<pre><code class="language-go">// Closes the network connection and unsets internal variables. Do not call this
// function after successfully authentication, call Close instead. This function
// is called before auth or on auth failure because MySQL will have already
// closed the network connection.
func (mc *mysqlConn) cleanup() {
    // Makes cleanup idempotent 保证函数的幂等性
  	if mc.netConn != nil {
      	if err := mc.netConn.Close(); err != nil { // Close 会尝试发送 comQuit command 到服务器
          	errLog.Print(err)
      	}
      	mc.netConn = nil // 不管 Close 是否成功，必须将 netConn 清空
  	}
  	mc.cfg = nil
	mc.buf.nc = nil // 缓冲器中的 netConn 也要关闭
}
</code></pre>

<h2 id="result-go">Result.go</h2>

<p>每当 <code>MySQL</code> 返回一个 <code>OK</code> 的 <strong>状态报文</strong> ，该报文协议会携带上本次执行的结果 <code>affectedRows</code> 以及 <code>insertId</code> ，而 <code>result.go</code> 就包含着一个数据结构，用于存储本次的执行结果。</p>

<pre><code class="language-go">type mysqlResult struct {
    affectedRows int64
  	insertId 	 int64
}

// 两个 getter
func (res *mysqlResult) LastInsertId() (int64, error) {
	return res.insertId, nil
}

func (res *mysqlResult) RowsAffected() (int64, error) {
	return res.affectedRows, nil
}
</code></pre>

<p>接下来我们看下在 <code>conntion.go</code> 中是怎么生成 <code>mysqlResult</code> 对象的：</p>

<pre><code class="language-go">// connect.go
func (mc *mysqlConn) Exec(query string, args []driver.Value) (driver.Result, error) {
  
  	// ...
  
  	err := exec(query)
  	if err == nil {
		return &amp;mysqlResult{ // 返回执行的结果
			affectedRows: int64(mc.affectedRows),
			insertId:     int64(mc.insertId),
		}, err
	}
	return nil, err
}

// exec 函数的解析可以返回上面 package.go 中浏览

// package.go
func (mc *mysqlConn) readResultSetHeaderPacket() (int, error) {
	data, err := mc.readPacket()
	if err == nil {
		switch data[0] {

		case iOK:
			return 0, mc.handleOkPacket(data) // 处理 OK 状态报文

		// ...
}

func (mc *mysqlConn) handleOkPacket(data []byte) error {
	var n, m int

	// 0x00 [1 byte]

	// Affected rows [Length Coded Binary]
	mc.affectedRows, _, n = readLengthEncodedInteger(data[1:])

	// Insert id [Length Coded Binary]
	mc.insertId, _, m = readLengthEncodedInteger(data[1+n:])

	// ...
}
</code></pre>

<h2 id="row-go">Row.go</h2>

<p>当 <code>MySQL</code> 执行 <strong>插入、更新、删除</strong> 等操作后，都会返回 <code>Result</code> ，但是 <strong>查询</strong> 返回的是 <code>Rows</code> ，我们先来看看 <code>go-mysql-driver</code> 驱动所实现的 <strong>接口</strong>  <code>Rows</code> 的接口描述：</p>

<pre><code class="language-go">// database/sql/driver/driver.go
// Rows 是执行查询返回的结果的 游标
type Rows interface {
    // Columns 返回列的名称，从 slice 的长度可以判断列的长度
  	// 如果一个列的名称未知，则为该列返回一个空字符串
  	Columns() []string
  
  	// Close 关闭游标
  	Close() error
  
  	// Next 将下一行数据填充到 desc 切片中
	// 如果读取的是最后一行数据，应该返回一个 io.EOF 错误
  	Next(desc []Value) error
}

type Value interface{} // Value is a value that drivers must be able to handle.
</code></pre>

<p>为什么我要说这是 <code>go-mysql-driver</code> 驱动所实现的 <strong>接口</strong> <code>Rows</code> 呢？眼尖的同学应该已经看到了， <code>Next</code> 函数好像和我们平常见到的不一样啊！！</p>

<p>是的，因为我们平常使用的：</p>

<ul>
<li><code>rows.Next()</code></li>
<li><code>rows.Scan(dest ...interface{}) error</code></li>
</ul>

<p>等函数的对象 <code>rows</code> 并不是上面的 <strong>接口描述</strong> <code>Rows</code> ，而是另一个封装的 <strong>同名数据结构</strong> <code>Rows</code> ，它就在 <code>database/sql</code> 包中 ：</p>

<pre><code class="language-go">// database/sql.go
type Rows struct {
    dc          *driverConn 
	releaseConn func(error)
	rowsi       driver.Rows // 接口描述的 Rows 藏在这！！！
	
	// 忽略其他字段，因为我们不分析这个包...
  
  	// lastcols is only used in Scan, Next, and NextResultSet which are expected
	// not not be called concurrently.
	lastcols []driver.Value
}
</code></pre>

<p>我们跳过 <code>database/sql</code>  包中的 <code>Rows</code> 实现，其无非是提供了更多功能的一个结果集而已，让我们回到真正与数据库进行交互的 <code>Rows</code> 中进行源码分析。</p>

<p>在 <code>go-sql-driver</code> 实现的 <code>mysqlRows</code> 数据结构只实现了 <code>Columns()</code> 和 <code>Close()</code> 两个行数，剩下的 <code>Next(desc []driver.Value)</code> 实现则交给了 <code>MySQL</code> 的两种结果集协议：</p>

<pre><code class="language-go">// rows.go

type mysqlField struct {
	tableName string
	name      string
	flags     fieldFlag
	fieldType byte
	decimals  byte
}

type mysqlRows struct {
	mc      *mysqlConn
	columns []mysqlField
}

type binaryRows struct { // 二进制结果集协议
	mysqlRows // 对于 Go 的 组合特性 应该不会陌生吧？
}

type textRows struct { // 文本结果集协议
	mysqlRows
}

func (rows *mysqlRows) Columns() []string {
  	columns := make([]string, len(rows.columns))
  	
  	// 将列名赋值到 columns ，如果有设置别名则赋值别名...
  
  	return columns
}

func (rows *mysqlRows) Close() error {
    // 将连接里面的未读数据读完，然后将连接置空
}

// 接下来的 Next 函数实现就交由 binaryRows 和 textRows 了
func (rows *binaryRows) Next(desc []driver.Value) error {
    if mc := rows.mc; mc != nil {
		if mc.netConn == nil {
			return ErrInvalidConn
		}

		return rows.readRow(dest) // 读二进制协议结果集
	}
	return io.EOF
}

func (rows *testRows) Next(desc []driver.Value) error {
    if mc := rows.mc; mc != nil {
		if mc.netConn == nil {
			return ErrInvalidConn
		}

		return rows.readRow(dest) // 读取文本协议
	}
	return io.EOF
}
</code></pre>

<p>可以说，实现了 <code>driver.Rows</code> 接口的只有 <code>binaryRows</code> 和 <code>testRows</code> ，而他们里面的 <code>readRow(desc)</code> 实现由于都是和协议强相关的代码，就不再解析了。</p>

<p>我们跟着源码可以看到，使用 <code>textRows</code> 的场景在 <code>getSystemVar</code> 以及 <code>Query</code> 中，而使用 <code>binaryRows</code> 的场景在 <code>statement</code> 中，就是我们下一步需要解析的部分。</p>

<h2 id="statement-go">Statement.go</h2>

<p><code>Prepared Statement</code> ，即预处理语句，他有什么优势呢，为什么 <code>MySQL</code> 要加入它？</p>

<ul>
<li>执行性能更高：<code>MySQL</code> 会对 <code>Prepared Statement</code> 语句预先进行编译成模板，并将 <strong>占位符</strong> 替换 <strong>参数</strong> 的位置，这样如果频繁执行一条参数只有少量替换的语句时候，性能会得到大量提高。可能有同学会有疑问，为什么 <code>MySQL</code> 语句还需要编译？那么可以来参考下这篇 <a href="http://www.cnblogs.com/justfortaste/p/3920140.html">MySQL Prepare 原理</a> 。</li>
<li>传输协议更优：<code>Prepare Statement</code> 在传输时候使用的是 <code>Binary Protocol</code> ，比使用 <code>Text Protocol</code> 的查询具有 <strong>传输数据量更小</strong> 、 <strong>无需转换数据格式</strong> 等优势，缓解了 <strong>CPU</strong> 和 <strong>网络</strong> 的开销。</li>
<li>安全性更好：由 <a href="http://www.cnblogs.com/justfortaste/p/3920140.html">MySQL Prepare 原理</a> 我们可以知道，<code>Perpare</code> 编译之后会生成 __语法树 __，在执行的时候才会将参数传进来，这样就避免了平常直接执行 <code>SQL 语句</code> 会发生的 <code>SQL 注入</code> 问题。</li>
</ul>

<p>好了，先来看下 <code>mysqlStmt</code> 的数据结构：</p>

<pre><code class="language-go">type mysqlStmt struct {
    mc 			*mysqlConn
  	id 			uint32
  	paramCount 	int
  	columns		[]mysqlField // cached from the first query (既然SQL已经预编译好了，返回的结果集列名已经是确定的，所以在收到 PREPARE_OK 之后解析数据后会缓存下来)
}
</code></pre>

<p>我们发现，它比 <code>mysqlRows</code> 多了两个成员变量：</p>

<ul>
<li><code>id</code> ：<code>MySQL</code> 预处理语句之后，会给该语句分配一个 <code>id</code> 并返回客户端，用于：

<ul>
<li>客户端提交该 <code>id</code> 给服务器调用对应的预处理语句。</li>
</ul></li>
<li><code>paramCount</code> ：参数数量，等于 <strong>占位符</strong> 的个数，用于：

<ul>
<li>判断传入的参数个数是否与预编译语句中的占位符个数一致。</li>
<li>判断返回的 <code>PREPARE_OK</code> 响应报文是否带有 <strong>参数列名</strong> 数据。</li>
</ul></li>
</ul>

<p>下面来看看如何创建并使用一个 <code>Prepare Statement</code> ：</p>

<pre><code class="language-go">func (mc *mysqlConn) Prepare(query string) (driver.Stmt, error) { // 传入需要预编译的 SQL 语句
    // 检查连接是否可用...
  
  	err = mc.writeCommandPacketStr(comStmtPrepare, query) // 将 SQL 发往数据库进行预编译
  	if err != nil {
		return nil, err
	}

	stmt := &amp;mysqlStmt{ // 预编译成功，先创建 stmt 对象
		mc: mc,
	}
  
  	// Read Result
  	columnCount, err := stmt.readPrepareResultPacket() // 从 stmt 的连接读取返回 响应报文
  	if err == nil {
      	if stmt.paramCount &gt; 0 { // 如果预编译的 SQL 的有参数
          	if err = mc.readUntilEOF(); err != nil { // 读取参数列名数据
				return nil, err
			}
      	}
      	
      	if columnCount &gt; 0 { // 返回执行结果的列表个数
			err = mc.readUntilEOF() // 读取执行结果的列名数据
		}
  	}
  
  	return stmt, err
}
</code></pre>

<p>因为是已经预编译好的语句，所以在执行的时候只需要将参数传进去就可以了。</p>

<pre><code class="language-go">func (stmt *mysqlStmt) Exec(args []driver.Value) (driver.Result, error) {
    // 检查连接是否可用...
  
  	err := stmt.writeExecutePacket(args)
	if err != nil {
		return nil, err
	}
  
  	// 读取结果集的行、列数据
}

func(stmt *mysqlStmt) writeExecutePacket(args []driver.Value) error {
  	if len(args) != stmt.paramCount { // 判断传进来的参数和预编译好的SQL参数 个数是否一致
		return fmt.Errorf(
			&quot;argument count mismatch (got: %d; has: %d)&quot;,
			len(args),
			stmt.paramCount,
		)
	}
  
  	// 读取缓冲器中的数据，如果为空，则返回异常...
  
  	// command [1 byte]
	data[4] = comStmtExecute

	// statement_id [4 bytes] 将预编译语句的 id 转换为 4字节的二进制数据
	data[5] = byte(stmt.id)
	data[6] = byte(stmt.id &gt;&gt; 8)
	data[7] = byte(stmt.id &gt;&gt; 16)
	data[8] = byte(stmt.id &gt;&gt; 24)

	// flags (0: CURSOR_TYPE_NO_CURSOR) [1 byte]
	data[9] = 0x00

	// iteration_count (uint32(1)) [4 bytes]
	data[10] = 0x01
	data[11] = 0x00
	data[12] = 0x00
	data[13] = 0x00
  
  	// 将参数按照不同的类型转换为 binary protobuf 并 append 到 data 中...
  
  	return mc.writePacket(data)
}
</code></pre>

<p>相信看到这里，已经能对看懂源码的 70% 了，剩余的代码都是和协议相关，就留待有兴趣的读者继续研究，这里就不再展开讲了。</p>

<h2 id="transaction-go">Transaction.go</h2>

<p>事务是 <code>MySQL</code> 中很重要的一部分，但是驱动的实现却很简单，因为一切的事务控制都已经交由 <code>MySQL</code> 去执行了，驱动所需要做的，只要发送一个 <code>commit</code> 或者 <code>rollback</code> 的 <code>command packet</code> 即可。</p>

<pre><code class="language-go">type mysqlTx struct {
	mc *mysqlConn
}

func (tx *mysqlTx) Commit() (err error) {
	if tx.mc == nil || tx.mc.netConn == nil {
		return ErrInvalidConn
	}
	err = tx.mc.exec(&quot;COMMIT&quot;)
	tx.mc = nil
	return
}

func (tx *mysqlTx) Rollback() (err error) {
	if tx.mc == nil || tx.mc.netConn == nil {
		return ErrInvalidConn
	}
	err = tx.mc.exec(&quot;ROLLBACK&quot;)
	tx.mc = nil
	return
}
</code></pre>

<h2 id="总结">总结</h2>

<p>最后，其实 <code>buffer</code> 的实现对我来说印象是最深刻的，因为它是最简单而又是最有效的实现了一个消息缓冲器，它实现的巧妙让我决定把它放到第一节，而其他的几乎都和 <code>MySQL</code> 的协议相关，看这些源码让我对 <code>MySQL</code> 有了更多的认识。</p>

<p>好了，本篇字数比较多，也会有很多不足，希望大家能够给本篇博客多提点意见，让我可以改进的更好。如果还有机会，我会带来其他篇章的源码解析，敬请期待 :)</p>

<h2 id="参考链接">参考链接</h2>

<ul>
<li><a href="http://www.cnblogs.com/davygeek/p/5647581.html">http://www.cnblogs.com/davygeek/p/5647581.html</a></li>
<li><a href="http://www.cnblogs.com/justfortaste/p/3920140.html">http://www.cnblogs.com/justfortaste/p/3920140.html</a></li>
<li><a href="http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#439-prepare_ok-prepared-statement">http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#439-prepare_ok-prepared-statement</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/golang-bad-file-descriptor/">
        Golang Error: bad file descriptor
      </a>
    </h1>

    <span class="post-date">Sat, Oct 15, 2016</span>

    

<h2 id="intro">Intro</h2>

<p>好久没写 Blog 了，正好今天写了一个爬取 <strong>Bing</strong> 首页高清图片的服务 Application =&gt; <a href="https://github.com/HackeZ/bingImgCrawer">bingImgCrawer</a> 碰到了之前遇到的一个写文件的问题，现在就将其纪录下来吧。</p>

<h2 id="problem">Problem</h2>

<p>我的需求是将匹配出来的 <strong>图片URL</strong> 按照日期纪录到 <code>img_url.txt</code> 文件中。</p>

<p>下面是我的问题代码：</p>

<pre><code class="language-golang">const (
    LogFile = &quot;./img_url.txt&quot;
)
func logFile(url string) {
    ver file *os.File 
    var err error
    if isExist(LogFile) {
        file, err = os.OpenFile(LogFile, os.O_APPEND, 0666)
    } else {
        log.Println(&quot;log file not exist, creating...&quot;)
		file, err = os.Create(LogFile)
    }
    defer file.Close()
    ...
}
</code></pre>

<p>当文件已经存在的时候，调用 <code>file, err = os.OpenFile(LogFile, O_APPEND, 0666)</code> 语句打开的 file 变量在使用 <code>file.WriteString(...)</code> 方法的时候，会出现错误信息：</p>

<pre><code>write ./img_url.txt: bad file descriptor
</code></pre>

<h2 id="solve">Solve</h2>

<p>当第一次遇到该错误的时候，我还以为是上一次的线程使用完 <code>img_url.txt</code> 之后没有释放掉文件句柄，而导致第二次获取该文件句柄的时候出现的 <code>bad file descriptor</code> 错误。</p>

<p>于是我将打开该文件的变量作为 <strong>全局变量</strong> 进行写入操作，问题依然没有得到解决（因为改动太多，代码就不放出来了）</p>

<p>于是只能借助万能的 stack overflow 了。。。</p>

<p>解决办法 =&gt; <a href="http://stackoverflow.com/questions/33851692/golang-bad-file-descriptor">Golang bad file descriptor</a></p>

<p>原来是我没有将写文件的 <strong>flag</strong> 也写进去&hellip;原来 <code>O_APPEND</code> 只是负责当用户有写入文件这个动作的时候，将文件指针指向文件结尾。</p>

<p>正确写法：</p>

<pre><code class="language-golang">    if isExist(LogFile) {
        file, err = os.OpenFile(LogFile, os.O_WRONLY | os.O_APPEND, 0666)
    } else {
        log.Println(&quot;log file not exist, creating...&quot;)
		file, err = os.Create(LogFile)
    }
</code></pre>

<p>最后再好奇一件事情， <code>os.O_WRONLY | os.O_APPEND</code> 的结果是什么呢？</p>

<p>上代码：</p>

<pre><code class="language-golang">func main() {
    fmt.Println(os.O_APPEND)  // 8
	fmt.Println(os.O_WRONLY)  // 1
	fmt.Println(os.O_RDWR)    // 2
	fmt.Println(os.O_APPEND | os.O_WRONLY) // 9
	fmt.Println(os.O_APPEND | os.O_RDWR)   // 10
}
</code></pre>

<p>最后翻定义，见 <code>/usr/local/go/src/syscall/zerrors_darwin_amd64.go</code> :</p>

<pre><code>    ...
    O_APPEND = 0x8
    ...
    O_RDWR = 0x2
    ...
    O_WRONLY = 0x1
    ...
</code></pre>

<p><strong>OVER</strong></p>

<h2 id="references">References</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/33851692/golang-bad-file-descriptor">Golang bad file descriptor</a></li>
<li><a href="http://blog.csdn.net/yjp19871013/article/details/8138449">关于打开文件时O_APPEND标志的作用</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/update_macos_problem/">
        Update Mac OS Problem
      </a>
    </h1>

    <span class="post-date">Wed, Sep 28, 2016</span>

    

<h2 id="intro">Intro</h2>

<p>最近将 Mac OS 升级到 Sierra(10.12) ，升级完成后，部分的 Go 应用无法正常启动了，下面说说我是怎么解决的。</p>

<h2 id="problem">Problem</h2>

<p>直接给出当我运行 <code>go-sqlite3</code> 包时候的报错信息吧：</p>

<pre><code class="language-shell">../github.com/mattn/go-sqlite3/sqlite3-binding.c:20515:17: warning: 'OSAtomicCompareAndSwapPtrBarrier' is deprecated: first deprecated in macOS 10.12 - Use atomic_compare_exchange_strong() from &lt;stdatomic.h&gt; instead [-Wdeprecated-declarations]
/usr/include/libkern/OSAtomicDeprecated.h:547:6: note: 'OSAtomicCompareAndSwapPtrBarrier' has been explicitly marked deprecated here
</code></pre>

<p>从报错的信息应该能猜想到是 <code>go-sqlite3</code> 包下的 <code>sqlite3-binding.c</code> 文件的依赖头文件不被支持了。</p>

<p>但是经过查看，该头文件的确存在而且应该是没有错误的，那么问题出现在哪呢？</p>

<h2 id="slove">Slove</h2>

<p>后来我想是不是因为这个包我没有更新而出现的不兼容呢？于是我尝试了：</p>

<ul>
<li>git pull</li>
<li>go install github.com/mattn/go-sqlite3</li>
<li>brew update # 因为我之前已经安装了，未安装的同学可以试试 $ brew install sqlite3</li>
</ul>

<p>当我运行到 brew 命令时候发现， <code>/usr/local/</code> 目录的权限在当前账户下无法进行写入？</p>

<p>猫腻出来了，接下来我输入 <code>$ sudo chown -R $(whoami) /usr/local</code> 更改权限，再次运行 <code>go-sqlite3</code> ，应用正常了！</p>

<h2 id="last">Last</h2>

<p>因为更新系统之后，账户的很多权限都会被覆盖掉，所以不要怕，多多尝试给权限，说不定就好了呢！</p>

<p>P.S. 更新完系统之后 <code>Git</code> 不能正常使用的，报错信息：</p>

<pre><code class="language-shell">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), 
missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun
</code></pre>

<p>可以通过命令 <code>xcode-select --install</code> 下载 XCODE 的插件解决。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/circuitbreaker/">
        CircuitBreaker 设计模式
      </a>
    </h1>

    <span class="post-date">Sun, Sep 25, 2016</span>

    

<h2 id="intro">Intro</h2>

<p>今天发现了 <a href="https://github.com/sony/">Sony</a> 竟然在 Github 上开源了他们的一些项目！而他们也是在用 <code>Golang</code> 在开发后台！</p>

<p><strong>Amazing</strong></p>

<p>于是不亦乐乎地看起了其中的 Golang 开源项目，而其中一个名为 <a href="https://github.com/sony/gobreaker">sony/gobreaker</a> 的项目引起了我的注意。</p>

<p>项目简述中描述了这是一个 Golang 版本的 <strong>CircuitBreaker</strong> 实现！</p>

<p>那么什么是 <strong>CircuitBreaker（断路器）</strong> 呢？下面就来一起看看。</p>

<h2 id="what-is-circuitbreaker">What is CircuitBreaker</h2>

<p>根据传统的解释，断路器是广泛用于 <em>电子工程产业</em> 的一个重要安全保障！</p>

<p>当你家里的洗衣机漏电了，电流就会瞬间增大，那么连接家里总线的 <strong>断路器</strong> 就会剩下，及时切断总电源，防止意外的发生！</p>

<p>那么在最近的 <code>微服务</code> 越来越流行的时代，软件架构开始将 <strong>断路器</strong> 这一概念添加进来了。</p>

<p>我们知道，当你一旦开始将系统中的一部分拆解为一个独立服务，那么你就已经走进了 <code>微服务</code> 的时代了。
而在微服务中最重要的是要保证服务运行的稳定性，如果独立服务无法提供高质量或者是不能提供服务，那么这将会导致整个系统的崩溃！</p>

<p>而 <code>微服务</code> 会遇到的故障有可能是：
    - 瞬时故障：如慢的网络连接、超时，资源过度使用而暂时不可用；
    - 不容易预见的突发故障：需要更长时间来纠正的故障；</p>

<p>而解决这些故障常常有两种方法：
    - 重试机制：对于预期的短暂故障问题，通过重试模式是可以解决的；
    - 断路器（CircuitBreaker）模式：将受保护的服务封装在一个可以监控故障的断路器对象中，当故障达到一定门限，断路器将跳闸（trip），所有后继调用将不会发往受保护的服务而由断路器对象之间返回错误。对于需要更长时间解决的故障问题，不断重试就没有太大意义了，可以使用断路器模式。</p>

<p><img src="http://martinfowler.com/bliki/images/circuitBreaker/sketch.png?_=0.814744712175792" alt="CircuitBreaker - Sketch" /></p>

<p><img src="http://martinfowler.com/bliki/images/circuitBreaker/state.png?_=0.47541342622693494" alt="CircuitBreaker - State" /></p>

<h2 id="action-in-gobreaker">Action in gobreaker</h2>

<p>简单介绍完 CircuitBreaker 的概念，那么接下来就结合 <a href="https://github.com/sony/gobreaker">gobreaker</a> 的源码实际看看如何设计一个 断触器。</p>

<p>首先一个值得我们关注的点是 CircuitBreaker State， 它被设计为 <strong>3</strong> 种状态：</p>

<pre><code class="language-go">type State int
const (
    StateClosed State = iota
    StateHalfOpen
    StateOpen
)
</code></pre>

<p>CircuitBreaker 会根据当前处于不同的 <code>State</code> ，而判断最多可以通过多少个 <code>Request</code> 。</p>

<p>接下来是 <code>Setting</code> ，通过 Setting 对象的值，可以新建出一个 CircuitBreaker ：</p>

<pre><code class="language-go">type Settings struct {
	Name          string  // CircuitBreaker 的名字
	MaxRequests   uint32  // 最大连接数，根据 State 会自动调节允许通过的 Request 值
	Interval      time.Duration // 当 CircuitBreaker 处于 Close 状态的时候，循环该时间段，清空连接数
	Timeout       time.Duration // 当 CircuitBreaker 处于 Open 状态的时候，如果触发了该超时时间，将它置为 Half-Open
	ReadyToTrip   func(counts Counts) bool // 判断当前失败数，是否应该进入 Close 状态
	OnStateChange func(name string, from State, to State) // 当状态发生变化时候，触发该函数
}

func NewCircuitBreaker(st Settings) *CircuitBreaker {
    ...
}
</code></pre>

<p>因为这个源码实现其实非常简单，我也就不一一讲诉了，就再将一个比较重要的函数 <code>Execute</code> 吧：</p>

<pre><code class="language-go">func (cb *CircuitBreaker) Execute(req func() (interface{}, error)) (interface{}, error) {
	generation, err := cb.beforeRequest()
	if err != nil {
		return nil, err
	}

	defer func() {
		e := recover()
		if e != nil {
			cb.afterRequest(generation, fmt.Errorf(&quot;panic in request&quot;))
			panic(e)
		}
	}()

	result, err := req()
	cb.afterRequest(generation, err)
	return result, err
}
</code></pre>

<p>该函数用于执行需要 CircuitBreaker 触发的函数，详情可以参考这里 =&gt; <a href="https://github.com/sony/gobreaker/blob/master/example/http_breaker.go">example</a></p>

<p>首先执行 CircuitBreaker 的 beforeRequest，然后执行传进来的 req 函数，最后执行 afterRequest ，并捕获异常，如果有异常， recover 它，不停止程序，返回错误信息。</p>

<h2 id="参考网站">参考网站</h2>

<p><a href="http://blog.sina.com.cn/s/blog_72ef7bea0102vvsn.html">mryqu - blog</a></p>

<p><a href="http://www.cnblogs.com/davidwang456/p/3976607.html">English</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/tcpdump-in-action/">
        tcpdump in Action
      </a>
    </h1>

    <span class="post-date">Fri, Sep 16, 2016</span>

    

<h2 id="intro">Intro</h2>

<p>昨天上线了新完成的网站 <a href="http://123.207.0.81:8563">Personal-Dictionary</a> <a href="https://www.github.com/HackeZ/Personal-Dictionary">源码在此</a></p>

<p>但是上线期间却发生网站从 <a href="http://127.0.0.1:8563">http://127.0.0.1:8563</a> 可以访问，但是外网访问却显示 <code>“无法访问此网络”</code> 的情况，最后通过分析抓包工具 <code>tcpdump</code> 的结果解决了该问题。</p>

<h2 id="problem">Problem</h2>

<p>这是一个 <code>Beego</code> 应用，按理来说只要编译出二进制文件，然后将静态文件和二进制文件发送到服务器端，然后运行该二进制文件即可。</p>

<p>编译 Linux OS 下可执行文件的命令为</p>

<p><code>$ CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o PD main.go</code></p>

<p>编译完成之后， 通过 <code>$ scp PD root@123.207.0.81:/home/...</code> 将文件上传至服务器。</p>

<p>使用 <code>$ nohup ./PD &amp;</code> 即可将该应用以后台服务的形式运行在服务器中。</p>

<p>但是问题出现了，通过外网的 IP 地址访问该 应用的端口地址却提示 <code>“无法访问此网络”</code> 的情况， 然后我使用 <code>$ curl http://127.0.0.1:8563</code> 却能直接返回网页内容！</p>

<h2 id="slove">Slove</h2>

<p>为了解决这个问题，我最先想到的就是该端口是否被外网的中间件屏蔽了呢。有一个最直观的方法可以观察检查该情况，就是使用 <code>tcpdump</code> 抓包工具！</p>

<p>在服务器端启动应用之后，使用 <code>$ tcpdump 网卡[eth0, lo] tcp port 8563 host 123.207.0.81</code></p>

<p>去截获访问该应用的端口 TCP 包，然后通过浏览器访问 <a href="http://123.207.0.81:8563">http://123.207.0.81:8563</a> 测试 TCP 包是否能正确到达 服务器的该端口。</p>

<p>结果 tcpdump 截获到的结果可以简化为</p>

<pre><code>.... [S]
.... [R.]
.... [S]
.... [R.]
.... [S]
.... [R.]
</code></pre>

<p>很明显了：
    - <code>S</code> 代表着 <code>SEND</code>
    - <code>R</code> 代表着 <code>RST</code></p>

<p>浏览器试图访问该端口，然后服务器直接就 RST 掉该请求，这样的情况下很可能就是该端口没有被打开！</p>

<p>关于更多的 RST 情况我推荐一篇 Blog —— <a href="https://my.oschina.net/costaxu/blog/127394">costaxu</a></p>

<p>根据上面的情况，我很快就能定位到问题所在：</p>

<pre><code class="language-go">// main.go
func main() {
    beego.Run(&quot;127.0.0.1&quot;+beego.AppConfig.String(&quot;httpport&quot;)) // 这里只指定了内网的服务地址...
}
</code></pre>

<p>最后，只需要将 <code>beego.Run()</code> 替换掉上面的即可解决。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/protocol-buffers/">
        Action in Protocol Buffers
      </a>
    </h1>

    <span class="post-date">Fri, Sep 9, 2016</span>

    

<h2 id="intro">Intro</h2>

<p>如果要介绍 <code>Protocol Buffers</code> 那么首先要从 RPC 说起，而熟悉分布式的同学应该都知道 RPC 吧，我简单介绍一下：</p>

<blockquote>
<p>PRC 也就是 Remote Procedure Call Protocol (远程调用协议)，也就是说当有 A, B 两台服务器，A 服务器 中可以通过 RPC 调用 B服务器 中的函数。</p>
</blockquote>

<p>在微服务和分布式变得越来越流行的今天，了解和学会 RPC 这个协议无疑是首要任务。</p>

<h2 id="protocol-buffers">Protocol Buffers</h2>

<p>那么 RPC 只是一个应用层协议，可以由不同的框架实现，而不同框架所支持的传输数据格式可以有很多：</p>

<ul>
<li>JSON</li>
<li>Gob</li>
<li>MessagePack</li>
<li>Protocol Buffers &hellip;</li>
</ul>

<p>那么可以说 <code>Protocol Buffers</code> 是这些所被支持的传输数据中比较高效而且通用的一种，其 <a href="https://developers.google.com/protocol-buffers/">官网</a> 就列举出如：</p>

<ul>
<li>C++</li>
<li>C#</li>
<li>Go</li>
<li>Java</li>
<li>Python</li>
</ul>

<p>的使用指南，而更多的如 <code>Ruby</code> <code>JavaNano</code> 等也可以被支持。</p>

<h2 id="install-in-go">Install in Go</h2>

<p>在 Go 中，我们可以直接使用 <code>protoc-gen-go</code> 这个工具由 <code>.proto</code> 模版文件直接生成可用的 <code>.go</code> 文件。</p>

<p>安装方法：</p>

<ol>
<li><p>首先需要下载 <code>Protobuf</code> 的编译器 <a href="https://github.com/google/protobuf/releases">protoc</a> ，你可以下载一个对应系统版本的二进制版本，然后解压缩之后会在 <code>bin</code> 文件夹下找到编译好的可执行文件。</p></li>

<li><p>然后需要安装 <code>protoc-gen-go</code> 插件和编解码支持库。</p></li>
</ol>

<pre><code class="language-shell"># 插件安装
$ go get github.com/golang/protobuf/protoc-gen-go
$ cd $\
GOPATH/src/github.com/golang/protobuf/protoc-gen-go
$ go build &amp;&amp; go install

# 编解码支持库
$ go get github.com/golang/protobuf/proto
$ cd $\
GOPATH/src/github.com/golang/golang/protobuf/proto
$ go build &amp;&amp; go install
</code></pre>

<p>最后还需要将 <code>$GOPAHTH/bin</code> <strong>加入环境变量</strong> ！</p>

<ol>
<li>安装完成之后，可以在测试文件夹里先新建一个 <code>.proto</code> 文件，往里面写入：</li>
</ol>

<pre><code class="language-go">syntax=&quot;proto2&quot;;
package xx // 该文件所属包名

enum FOO { X = 17; };

message Test {
    required string label = 1;
    optional int32 type = 2 [default=77];
    repeated int64 reps = 3;
    optional group OptionalGroup = 4 {
    required string RequiredField = 5;
    }
}
</code></pre>

<p>然后运行 <code>protoc -I='*.proto文件所处的文件夹' --go_out=. *.proto</code> 即可生成以下内容：</p>

<pre><code class="language-go">// Code generated by protoc-gen-go.
// source: example/human.proto
// DO NOT EDIT!

/*
Package example is a generated protocol buffer package.

It is generated from these files:
       	example/human.proto

It has these top-level messages:
       	Test
*/
package example

import proto &quot;github.com/golang/protobuf/proto&quot;
import fmt &quot;fmt&quot;
import math &quot;math&quot;

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FOO int32

const (
       	FOO_X FOO = 17
)

var FOO_name = map[int32]string{
       	17: &quot;X&quot;,
}
var FOO_value = map[string]int32{
       	&quot;X&quot;: 17,
}

func (x FOO) Enum() *FOO {
       	p := new(FOO)
       	*p = x
       	return p
}
func (x FOO) String() string {
       	return proto.EnumName(FOO_name, int32(x))
}
func (x *FOO) UnmarshalJSON(data []byte) error {
       	value, err := proto.UnmarshalJSONEnum(FOO_value, data, &quot;FOO&quot;)
       	if err != nil {
       		return err
       	}
       	*x = FOO(value)
       	return nil
}
func (FOO) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Test struct {
       	Label            *string             `protobuf:&quot;bytes,1,req,name=label&quot; json:&quot;label,omitempty&quot;`
       	Type             *int32              `protobuf:&quot;varint,2,opt,name=type,def=77&quot; json:&quot;type,omitempty&quot;`
       	Reps             []int64             `protobuf:&quot;varint,3,rep,name=reps&quot; json:&quot;reps,omitempty&quot;`
       	Optionalgroup    *Test_OptionalGroup `protobuf:&quot;group,4,opt,name=OptionalGroup,json=optionalgroup&quot; json:&quot;optionalgroup,omitempty&quot;`
       	XXX_unrecognized []byte              `json:&quot;-&quot;`
}

func (m *Test) Reset()                    { *m = Test{} }
func (m *Test) String() string            { return proto.CompactTextString(m) }
func (*Test) ProtoMessage()               {}
func (*Test) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

const Default_Test_Type int32 = 77

func (m *Test) GetLabel() string {
       	if m != nil &amp;&amp; m.Label != nil {
       		return *m.Label
       	}
       	return &quot;&quot;
}

func (m *Test) GetType() int32 {
       	if m != nil &amp;&amp; m.Type != nil {
       		return *m.Type
       	}
       	return Default_Test_Type
}

func (m *Test) GetReps() []int64 {
       	if m != nil {
       		return m.Reps
       	}
       	return nil
}

func (m *Test) GetOptionalgroup() *Test_OptionalGroup {
       	if m != nil {
       		return m.Optionalgroup
       	}
       	return nil
}

type Test_OptionalGroup struct {
       	RequiredField    *string `protobuf:&quot;bytes,5,req,name=RequiredField,json=requiredField&quot; json:&quot;RequiredField,omitempty&quot;`
       	XXX_unrecognized []byte  `json:&quot;-&quot;`
}

func (m *Test_OptionalGroup) Reset()                    { *m = Test_OptionalGroup{} }
func (m *Test_OptionalGroup) String() string            { return proto.CompactTextString(m) }
func (*Test_OptionalGroup) ProtoMessage()               {}
func (*Test_OptionalGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *Test_OptionalGroup) GetRequiredField() string {
       	if m != nil &amp;&amp; m.RequiredField != nil {
       		return *m.RequiredField
       	}
       	return &quot;&quot;
}

func init() {
       	proto.RegisterType((*Test)(nil), &quot;example.Test&quot;)
       	proto.RegisterType((*Test_OptionalGroup)(nil), &quot;example.Test.OptionalGroup&quot;)
       	proto.RegisterEnum(&quot;example.FOO&quot;, FOO_name, FOO_value)
}

func init() { proto.RegisterFile(&quot;example/human.proto&quot;, fileDescriptor0) }

var fileDescriptor0 = []byte{
       	// 200 bytes of a gzipped FileDescriptorProto
       	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0x12, 0x4e, 0xad, 0x48, 0xcc,
       	0x2d, 0xc8, 0x49, 0xd5, 0xcf, 0x28, 0xcd, 0x4d, 0xcc, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17,
       	0x62, 0x87, 0x0a, 0x2a, 0x1d, 0x62, 0xe4, 0x62, 0x09, 0x49, 0x2d, 0x2e, 0x11, 0x12, 0xe1, 0x62,
       	0xcd, 0x49, 0x4c, 0x4a, 0xcd, 0x91, 0x60, 0x54, 0x60, 0xd2, 0xe0, 0x0c, 0x82, 0x70, 0x84, 0xc4,
       	0xb8, 0x58, 0x4a, 0x2a, 0x0b, 0x52, 0x25, 0x98, 0x14, 0x18, 0x35, 0x58, 0xad, 0x98, 0xcc, 0xcd,
       	0x83, 0xc0, 0x7c, 0x21, 0x21, 0x2e, 0x96, 0xa2, 0xd4, 0x82, 0x62, 0x09, 0x66, 0x05, 0x66, 0x0d,
       	0xe6, 0x20, 0x30, 0x5b, 0xc8, 0x91, 0x8b, 0x37, 0xbf, 0xa0, 0x24, 0x33, 0x3f, 0x2f, 0x31, 0x27,
       	0xbd, 0x28, 0xbf, 0xb4, 0x40, 0x82, 0x45, 0x81, 0x51, 0x83, 0xcb, 0x48, 0x5a, 0x0f, 0x6a, 0x97,
       	0x1e, 0xc8, 0x1e, 0x3d, 0x7f, 0xa8, 0x12, 0x77, 0x90, 0x92, 0x20, 0x54, 0x1d, 0x52, 0xa6, 0x5c,
       	0xbc, 0x28, 0xf2, 0x42, 0x2a, 0x5c, 0xbc, 0x41, 0xa9, 0x85, 0xa5, 0x99, 0x45, 0xa9, 0x29, 0x6e,
       	0x99, 0xa9, 0x39, 0x29, 0x12, 0xac, 0x60, 0xd7, 0xf1, 0x16, 0x21, 0x0b, 0x6a, 0xf1, 0x70, 0x31,
       	0xbb, 0xf9, 0xfb, 0x0b, 0xb1, 0x72, 0x31, 0x46, 0x08, 0x08, 0x02, 0x02, 0x00, 0x00, 0xff, 0xff,
       	0x89, 0x47, 0xa8, 0x4e, 0xf1, 0x00, 0x00, 0x00,
}
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/how2use-captcha-in-beego/">
        How to Use Captcha in Beego Correct
      </a>
    </h1>

    <span class="post-date">Thu, Sep 1, 2016</span>

    

<h2 id="intro">Intro</h2>

<p>最近在做 Beego 的 Web 网站开发，主题是 <code>个人词典</code> ，项目地址 <a href="https://github.com/HackeZ/Personal-Dictionary">点我</a> 。
在关于 Beego 的验证码使用方法上出现了问题，后面通过阅读 Beego 的源码解决了该问题，下面来详细讲诉一下。</p>

<h2 id="problem">Problem</h2>

<p>先来看看错误的代码吧</p>

<pre><code class="language-go">// ...
var cpt *captcha.Captcha

func (c *MainController) Login () {
    // ...
    // Get Verification Code.
    store = cache.NewMemoryCache()
    cpt = captcha.NewWithFilter(&quot;/captcha/&quot;, store)
	cpt.ChallengeNums, _ = beego.AppConfig.Int(&quot;captcha_length&quot;)
	cpt.StdWidth = 100
	cpt.StdHeight = 42

    c.TplName = &quot;login.tpl&quot;
}
</code></pre>

<p>这样写出现的问题是，开启服务器之后，只有第一次输入的验证码是正确的，一旦刷新页面或者已经登录之后，无论再次怎么进行登录都是 <code>验证码不正确</code> 的错误。
甚至在很多情况下都会出现验证码图片显示不出来。</p>

<h2 id="solve">Solve</h2>

<p>其实很容易就可以想到是 Cache 模块而导致的问题，因为 Beego 的 Memory Cache 从源代码中看其实就是一个存放在内存的 <code>Map</code> ，而且该 <code>Map</code> 是带生存周期的。所以应该将 <code>Cache</code> 设置为一个全局变量，那么才能可以让 <code>Captcha</code> 每次都能到正确的内存地址中的 Map 存取数据。而不是每次访问都新建一次 <code>Cache</code> 。</p>

<p>正确的用法如下：</p>

<pre><code class="language-go">// ...
var cpt *captcha.Captcha
var store cache.Cache

func (c *MainController) Login () {
    // ...
    // Get Verification Code.
    cpt = captcha.NewWithFilter(&quot;/captcha/&quot;, store)
	cpt.ChallengeNums, _ = beego.AppConfig.Int(&quot;captcha_length&quot;)
	cpt.StdWidth = 100
	cpt.StdHeight = 42

    c.TplName = &quot;login.tpl&quot;
}

func init() {
    store = cache.NewMemoryCache()
}
</code></pre>

<p>这样，无论是怎么折腾该验证码， <code>Captcha</code> 都能到正确的 <code>Map</code> 中进行操作，一切的问题都解决了。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/fun-in-docker-2/">
        Fun in Docker Day-2
      </a>
    </h1>

    <span class="post-date">Wed, Aug 31, 2016</span>

    

<h2 id="intro">Intro</h2>

<p>今天来详细讲一下之前没有讲清楚的 Docker 镜像打包方法。</p>

<h2 id="page-command">Page Command</h2>

<p>我们都知道，打包 Docker 应用有两种方式：</p>

<ol>
<li>在已经存在的 images 中 commit 修改。</li>
<li>创建一个全新的 images 。</li>
</ol>

<p>这两种方法各有优缺点。下面都来说一下怎么进行操作。</p>

<h2 id="way-one">Way One</h2>

<p>在已有的 images 中修改并 commit</p>

<ul>
<li>优点：

<ul>
<li>这是最方便快捷的方法</li>
<li>可以避免自己打包而导致出现的一些问题，如静态文件引用错误等</li>
</ul></li>
<li>缺点：

<ul>
<li>可定制程度低</li>
<li>打包出来的镜像文件可能会很大，不利于存储</li>
</ul></li>
</ul>

<p>在 Docker 官网的文档中已经很详细操作过了，下面的是我翻译的版本。具体的官方英文<a href="https://docs.docker.com/engine/tutorials/dockerimages/#/updating-and-committing-an-image">点我</a></p>

<p>首先你需要一个 images 才能进行更新操作呀，所以首先：</p>

<pre><code class="language-shell">#   获取 images
$ docker pull training/sinatra
#   运行 images 并进入到命令行中
$ docker run -t -i training/sinatra /bin/bash
root@0b2616b0e5a8:/#
</code></pre>

<blockquote>
<p>记住这个被创建容器的 ID， <code>0b2616b0e5a8</code> ，一会你会用得上的。</p>
</blockquote>

<p>接上面的操作&hellip;</p>

<pre><code class="language-shell">#   首先更新一下 Ruby
root@0b2616b0e5a8:/# apt-get install -y ruby2.0-dev
#   然后安装  gem  json
root@0b2616b0e5a8:/# gem2.0 install json
</code></pre>

<p>完成了这些更改之后，你可以运行 <code>exit</code> 命令退出。</p>

<p>现在你可以像使用 <code>git</code> 一样更新这个镜像了：</p>

<pre><code class="language-shell">#   '-m' '-a' 这些看起来很熟悉啦，和 git 中是一样的，就不再说了...
$ docker commit -m &quot;Added json gem&quot; -a &quot;Kate Smith&quot; \
0b2616b0e5a8 ouruser/sinatra:v2

4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c
</code></pre>

<p>然后运行一下 <code>docker images</code> 来看看新创建的容器吧</p>

<pre><code class="language-shell">$ docker images

REPOSITORY          TAG     IMAGE ID       CREATED       SIZE
training/sinatra    latest  5bc342fa0b91   10 hours ago  446.7 MB
ouruser/sinatra     v2      3c59e02ddd1a   10 hours ago  446.7 MB
ouruser/sinatra     latest  5db5f8471261   10 hours ago  446.7 MB
</code></pre>

<h2 id="way-two">Way Two</h2>

<p>完全创建一个新的 images 是很多人第一时间就想做的，但是官网简介中并没有太多详细标注的细节，那么我就以我的第一视角讲诉一下我是怎么创建一个全新的  images 的。</p>

<p>依然是 Go ，首先创建一个简单的读取文件内容的项目：</p>

<pre><code class="language-shell">$ cd $GOPATH/src
$ mkdir File_Reader
$ vim File_Reader/main.go
</code></pre>

<p>源代码如下：</p>

<pre><code class="language-go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	file, err := os.OpenFile(&quot;./file.txt&quot;, os.O_RDONLY, os.ModePerm)
	defer file.Close()

	if err != nil {
		log.Println(&quot;file.txt open false!&quot;)
	}

	fileReader := bufio.NewReader(file)

	for {
		line, err := fileReader.ReadString('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			log.Println(&quot;Read File Content Failed!&quot;, err.Error())
			return
		}
		fmt.Println(line)
	}

	fmt.Println(&quot;File Read Done!&quot;)
}
</code></pre>

<p>接下来就是在当前目录下创建一个 <code>file.txt</code> ，然后输入你想要的内容进去。</p>

<pre><code class="language-shell">$ &quot;xxxxxx&quot; &gt;&gt; file.txt
</code></pre>

<p>接下来就需要先将源代码文件编译成二进制文件，因为如果我们希望这个 images 越小，越少的编译环境可以达到更好的效果。
命令如之前一样：</p>

<pre><code class="language-shell">$ CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .
</code></pre>

<p>然后你可以看到当前目录下出现了一个 <code>main</code> 的可执行文件。</p>

<p>重要的步骤来了，当前目录下创建一个 <code>Dockerfile</code> 文件，输入如下内容：</p>

<pre><code>FROM scratch
MAINTAINER HackerZ
ADD main /
ADD file.txt /
CMD [&quot;/main&quot;]
</code></pre>

<p>我来解释一下这些都是什么意思：</p>

<ul>
<li>FROM : Docker 用来指定该镜像是基于哪个基础镜像构建的</li>
<li>MAINTAINER : 镜像创建人的名字</li>
<li>ADD  : 从 Dockerfile 所在目录拷贝文件到指定路径下</li>
<li>CMD  : 用来指示当运行 <code>docker run</code> 命令运行该镜像时要执行的命令</li>
</ul>

<p>其余的还有：</p>

<ul>
<li>EXPOSE : 开放的网络端口号</li>
<li>ENV    : 设置环境变量</li>
<li>VOLUME : 可以将本地文件夹或者其他容器的文件夹挂载到该容器中。</li>
<li>WORKDIR: 切换目录用，可以多次切换(相当于cd命令)，对RUN,CMD,ENTRYPOINT生效</li>
<li>ONBUILD: ONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行</li>
</ul>

<p>好了，运行 <code>docker build -t fileReader .</code> 创建全新的 images 吧。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/fun-in-docker-1/">
        Fun in Docker Day-1
      </a>
    </h1>

    <span class="post-date">Sat, Aug 20, 2016</span>

    

<h2 id="intro">Intro</h2>

<p>今天心血来潮，想在 OSX 中重新体验一下 <code>Docker</code>，结果因为 <code>Docker</code> 是基于 <code>Linux</code>，在 OSX 中实在是 Fun 不起来，于是便纪录下来这天的过程。</p>

<h2 id="install">Install</h2>

<p>这部分没什么好说的， <code>Docker</code> 官方已经出了 <a href="https://docs.docker.com/docker-for-mac/">OSX</a> 的安装包，直接下载拖进 <code>Application/</code> 即可完成安装。</p>

<p>安装完成之后，可以直接在命令行中运行：</p>

<pre><code class="language-shell">$ docker --version  # Docker 主体
$ docker-compose --version  # 定义和管理复杂 Docker 应用的工具
$ docker-machine --version  # 简化 Docker 安装的工具
</code></pre>

<p>查看所有的安装工具是否能够正确启动。</p>

<p>之后，便可以尝试运行 <code>Hello World</code> 和 <code>nginx</code> 玩一下了。</p>

<pre><code class="language-shell"># Hello World
$ docker run hello-world

# nginx
$ docker run -d -p 80:80 --name webserver nginx
</code></pre>

<h2 id="package">Package</h2>

<p>以我的开源项目 <a href="https://www.github.com/HackeZ/getMeizi">getMeizi</a> 为例子尝试打包 <code>Golang应用</code> 。</p>

<h4 id="first-try">First Try</h4>

<p>首先我在项目的根目录下编写了一个 <code>Dockerfile</code> 文件，其内容为：</p>

<pre><code>FROM golang:onbuild
</code></pre>

<p>然后通过 <code>$ docker build -t getmeizi .</code> 来构建一个镜像。</p>

<p>但是这样构建的镜像会将 <code>Golang</code> 的整个环境都打包进去，生成的镜像大小为 <code>832.5 MB</code> 。</p>

<p>很显然我们会更加愿意得到一个更灵活小巧的镜像，于是，我的目光转向了 <code>scratch</code> 。</p>

<h4 id="second-try">Second Try</h4>

<p>修改 <code>Dockerfile</code> 文件内容为：</p>

<pre><code>FROM scratch
ADD main /
CMD [&quot;/main&quot;]
</code></pre>

<p>然后先将 <code>getMeizi</code> 应用编译完：</p>

<pre><code>$ CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .
</code></pre>

<p>最后使用 <code>$ docker build -t getmeizi .</code></p>

<p>构建即可生成一个仅有 <code>5.83 MB</code> 大小的镜像。</p>

<h2 id="push">Push</h2>

<p>最后将打包好的镜像发布到 <strong>Docker.io</strong> 中：</p>

<pre><code class="language-shell">$ docker images
# REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
# getmeizi            latest              7ddcbed63a17        2 minutes ago         5.839 MB

$ docker tag 7ddcbed63a17 hackerz/getmeizi

$ docker images
# REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
# getmeizi            latest              7ddcbed63a17        3 minutes ago         5.839 MB
# hackerz/getmeizi    latest              7ddcbed63a17        3 minutes ago         5.839 MB

$ docker login
# ***
# Login Succeeded

$ docker push hackerz/getmeizi
</code></pre>

<p>打开 <a href="https://hub.docker.com/r/hackerz/getmeizi/">hackerz/getmeizi</a> 查看并编辑镜像描述。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/global_gitignore/">
        Global Ignore File in Git
      </a>
    </h1>

    <span class="post-date">Thu, Aug 18, 2016</span>

    

<h2 id="intro">Intro</h2>

<p>自从换了 OSX 进行开发，就发现每当修改了项目文件， OSX 在项目目录都会生成一个 <code>.DS_Store</code> 的隐藏文件，该文件用于记录当前目录下文件的 Meta 信息。</p>

<p>对于这样的情况，我不可能在每个项目的根目录都配置一个 <code>.gitignore</code> 文件，这样可复用性太地了，于是我便想能不能配置一个 Git 的 <code>.gitignore_global</code> 文件，统一忽略掉所有我不需要上传的文件呢。</p>

<h2 id="solve">Solve</h2>

<p>Git 还真有这样的方法，它提供了一个 <strong>忽略规则</strong> ，我们可以通过编写一个忽略规则文件，然后通过如下的命令配置进 Git :</p>

<pre><code class="language-shell">$ git config --global core.excludesfile '忽略文件完整路径'
</code></pre>

<p>即可。</p>

<h2 id="global-gitignore">Global GitIgnore</h2>

<p>新建一个 <code>.gitignore_global</code> 文件，并往里面编写忽略文件语法，该语法符合正则表达式， <code>#</code> 号为注释，每一行为一个忽略规则：</p>

<pre><code class="language-shell"># OSX
.DS_Store
.DS_Store*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Python
*.pyc

# C
*.[ao]

# Package
*.7z
*.dmg
*.gz
*.iso
*.jar
*.rar
*.tar
*.zip
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/how-2-install-scikit-learn/">
        How To Install Scikit-learn Under OSX 10.11
      </a>
    </h1>

    <span class="post-date">Mon, Aug 15, 2016</span>

    

<h1 id="如何在osx下安装正确安装-scikit-learn">如何在osx下安装正确安装 scikit-learn</h1>

<h3 id="使用-anaconda">使用 Anaconda</h3>

<p><code>Anaconda</code> 是一个 Python 的集成科学计算环境，一键安装，方便好用。但是当我安装之后发现其只有自带了：</p>

<ul>
<li>numpy</li>
<li>scipy</li>
</ul>

<p>而并没有 <code>scikit-learn</code>，然后当我使用</p>

<pre><code class="language-shell">conda install scikit-learn
</code></pre>

<p>进行安装之后发现还是无法使用这个缺省的库，经我多方查找资料，原来是 <code>Mac 10.11</code> 版本中自带的 <code>Python 2.7</code> 环境与 <code>Anaconda</code> 的环境是分离的，所以只能 <code>Anaconda</code> 中使用这些库。</p>

<p>然而这是我不太喜欢的一种方式，所以我放弃了，转而研究在 <code>Mac</code> 自带的 Python 环境中安装。</p>

<h3 id="解除-osx-10-11-的-sip-限制">解除 OSX 10.11 的 ｀SIP｀ 限制</h3>

<p>当我开始用 <code>pip</code> 安装第三方包的时候出现了如下的错误：</p>

<pre><code class="language-shell">Collecting numpy

Using cached numpy-1.10.2-cp27-none-macosx_10_6_intel.macosx_10_9_intel.macosx_10_9_x86_64.macosx_10_10_intel.macosx_10_10_x86_64.whlInstalling
 collected packages: numpy
 Found existing installation: numpy 1.8.0rc1
 DEPRECATION: Uninstalling a distutils installed project (numpy) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project.
 Uninstalling numpy-1.8.0rc1:Exception:Traceback
 (most recent call last):
 File &quot;/Library/Python/2.7/site-packages/pip-7.1.2-py2.7.egg/pip/basecommand.py&quot;, line 211, in main
 status = self.run(options, args)
 File &quot;/Library/Python/2.7/site-packages/pip-7.1.2-py2.7.egg/pip/commands/install.py&quot;, line 311, in run
 root=options.root_path,
 File &quot;/Library/Python/2.7/site-packages/pip-7.1.2-py2.7.egg/pip/req/req_set.py&quot;, line 640, in install
 requirement.uninstall(auto_confirm=True)
 File &quot;/Library/Python/2.7/site-packages/pip-7.1.2-py2.7.egg/pip/req/req_install.py&quot;, line 716, in uninstall
 paths_to_remove.remove(auto_confirm)
 File &quot;/Library/Python/2.7/site-packages/pip-7.1.2-py2.7.egg/pip/req/req_uninstall.py&quot;, line 125, in remove
 renames(path, new_path)
 File &quot;/Library/Python/2.7/site-packages/pip-7.1.2-py2.7.egg/pip/utils/__init__.py&quot;,
 line 315, in renames
shutil.move(old, new)
 File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 302, in move
 copy2(src, real_dst)
 File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 131, in copy2
 copystat(src, dst)
 File &quot;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/shutil.py&quot;, line 103, in copystat
 os.chflags(dst, st.st_flags)OSError:
 [Errno 1] Operation not permitted: '/var/folders/5n/vbm997m56xg3kw67y6bccn2m0000gn/T/pip-4tcBsd-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy-1.8.0rc1-py2.7.egg-info'
</code></pre>

<p>仔细一看，发现了 <code>Operation not permitted</code> 的错误。</p>

<p>经过 Google ，发现了原来是 Apple 经历了 <code>XCode编译器注入</code> 事件之后，提升了 <code>Mac OS X El Capitan系统</code> 的安全保护机制，加入了：</p>

<blockquote>
<p>System Integrity Protection (SIP)
—— 系统完整性保护，其作用为强制性地保护系统相关的文件夹，开发者不能直接操作相关的文件内容。</p>
</blockquote>

<p>而 Python 库所在的路径为：</p>

<pre><code class="language-shell">/System/Library/Frameworks/Python.framework/Versions/2.7/...
</code></pre>

<p>当然是属于其完整性保护的保护伞之下的，所以我需要把 <code>SIP</code> 关掉之后才能对其进行安装。</p>

<p>引用外国大牛的关闭 SIP 的方法如下：</p>

<ol>
<li>Click the  menu.</li>
<li>Select <code>Restart</code> …</li>
<li>Hold down <code>command-R</code> to boot into the Recovery System.</li>
<li>Click the <code>Utilities menu</code> and select <code>Terminal</code>.</li>
<li>Type <code>csrutil disable</code> and press <code>return</code> .</li>
<li>Close the <code>Terminal</code> app.</li>
<li>Click the  menu and select <code>Restart</code> … .</li>
</ol>

<p>当然在安装完成之后最好还是将 SIP 重新打开：</p>

<ol>
<li>Click the  menu.</li>
<li>Select <code>Restart</code> …</li>
<li>Hold down <code>command-R</code> to boot into the Recovery System.</li>
<li>Click the <code>Utilities menu</code> and select <code>Terminal</code>.</li>
<li>Type <code>csrutil enable</code> and press <code>return</code> .</li>
<li>Close the <code>Terminal</code> app.</li>
<li>Click the  menu and select <code>Restart</code> … .</li>
</ol>

<h3 id="安装-scikit-learn-的正确姿势">安装 scikit-learn 的正确姿势</h3>

<p>好吧，终于解决了上面这些问题了，安装应该没有问题了吧？很可惜，当我运行完：</p>

<pre><code class="language-shell">$ sudo pip install numpy
$ sudo pip install scipy
$ sudo pip install scikit-learn
</code></pre>

<p>然后在 <code>Python</code> 下 <code>import sklearn</code> 时发生了如下错误：</p>

<pre><code class="language-shell">Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File &quot;/Library/Python/2.7/site-packages/sklearn/__init__.py&quot;, line 57, in &lt;module&gt;
from .base import clone
File &quot;/Library/Python/2.7/site-packages/sklearn/base.py&quot;, line 11, in &lt;module&gt;
from .utils.fixes import signature
File &quot;/Library/Python/2.7/site-packages/sklearn/utils/__init__.py&quot;, line 10, in &lt;module&gt;
from .murmurhash import murmurhash3_32
File &quot;numpy.pxd&quot;, line 155, in init sklearn.utils.murmurhash (sklearn/utils/murmurhash.c:5029)
ValueError: numpy.dtype has the wrong size, try recompiling
</code></pre>

<p>好惨，经过多方搜索，绝大部分的解答都是：</p>

<pre><code class="language-shell">$ pip uninstall numpy scipy scikit-learn
$ pip install numpy scipy scikit-learn
</code></pre>

<p>然而都并没有什么卵用，最后在这里找到了解决办法 =&gt; <a href="http://scikit-learn-general.narkive.com/kMA6mRCk/valueerror-numpy-dtype-has-the-wrong-size-try-recompiling">here</a></p>

<p>其方法时不要使用 <code>pip install scikit-learn</code></p>

<p>而是到 Github 中找到 <a href="https://github.com/scikit-learn/scikit-learn">scikit-learn</a> 项目进行安装：</p>

<pre><code class="language-shell">$ git clone https://github.com/scikit-learn/scikit-learn.git
$ sudo python setup.py install
</code></pre>

<p>等待几分钟，安装完成，大功告成～</p>

<h3 id="参考网站">参考网站：</h3>

<ul>
<li>在 osx 10.11 下解除 pip 权限安装 =&gt; <a href="http://blog.csdn.net/shi_weihappy/article/details/50938486">参考地址</a></li>
<li>如何正确安装scikit-learn =&gt; <a href="http://www.tuicool.com/articles/aEJriuY">参考地址</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/golang-package-dependency-management-tool/">
        Golang Package Dependency Management Tool
      </a>
    </h1>

    <span class="post-date">Sun, Aug 7, 2016</span>

    

<h1 id="golang-package-dependency-management-tool">Golang Package Dependency Management Tool</h1>

<h2 id="intro">Intro</h2>

<p>Golang一直以来被外界诟病的一个问题就是包的依赖管理问题。那么今天就来讲一个：</p>

<blockquote>
<p>Golang包依赖管理工具 —— gb</p>
</blockquote>

<p>gb 在其官网中定义自己为：</p>

<blockquote>
<p>A project based build tool for the Go programming language.</p>
</blockquote>

<p>一个Golang的项目工程通常由 <code>bin</code>、<code>pkg</code>、<code>src</code>三个子目录构成：</p>

<ul>
<li>bin : 存放编译后生成的可执行文件</li>
<li>pkg : 编译后生成的文件（如：.a）</li>
<li>src : 存放源代码（如：.go .c .h .s等）</li>
</ul>

<p>而 <code>gb</code> 在这个概念的基础上新增了一个 <code>vendor</code> 目录来存放项目依赖的第三方包（如 <em>beego</em> ，<em>gracehttp</em> 等）</p>

<h2 id="gb-action">gb action</h2>

<h4 id="install">Install</h4>

<p>gb ==&gt; <a href="https://getgb.io/">首页</a>  ==&gt;  <a href="https://github.com/constabulary/gb/">Github</a></p>

<p>根据说明，使用</p>

<pre><code class="language-shell">$ go get github.com/constabulary/gb/...
</code></pre>

<p>命令即可安装 gb。</p>

<p>当该命令运行完毕，请检查 <code>env</code> 下的第一个 <code>$GOPATH</code> 的 <code>bin</code> 目录下是否生成了 <code>gb</code> 以及 <code>gb-vendor</code> 两个可执行文件。</p>

<blockquote>
<p>如安装报错，请检查你是否正确配置了 $GOPATH 等环境变量。</p>
</blockquote>

<h4 id="use">Use</h4>

<p>下面试着使用 <code>gb</code> 来构建一个基于第三方包 <code>gracehttp</code> 的简易 Golang Web 项目，来体验一下 <code>gb</code> 的魅力。</p>

<p>首先初始化 <code>hellogb</code> 项目目录结构：</p>

<pre><code class="language-shell">$ cd $GOPATH/src/hellogb
$ mkdir -p src/hellogb
$ mkdir -p vendor/src
</code></pre>

<p>编写 Web 程序：</p>

<pre><code class="language-go">// vim src/hellogb/main.go
package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;

    &quot;github.com/tabalt/gracehttp&quot;
)

func main() {
    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &quot;hello gb&quot;)
    })

    err := gracehttp.ListenAndServe(&quot;:8080&quot;, nil)
    if err != nil {
        fmt.Println(err)
    }
}
</code></pre>

<p>使用 <code>gb</code> 添加依赖的 <code>gracehttp</code> 第三方包：</p>

<pre><code class="language-shell">$ gb vendor fetch github.com/tabalt/gracehttp
</code></pre>

<p>最终整个项目目录结构为：</p>

<pre><code>./
|-- src
|   `-- hellogb
|       `-- main.go
`-- vendor
    |-- manifest
    `-- src
        `-- github.com
            `-- tabalt
                `-- gracehttp
                    |-- README.md
                    |-- connection.go
                    |-- gracehttpdemo
                    |   `-- main.go
                    |-- listener.go
                    `-- server.go
</code></pre>

<p>编译执行程序：</p>

<pre><code class="language-shell">$ gb build hellogb
$ ./bin/hellogb
</code></pre>

<p>最后访问 <code>http://127.0.0.1:8080/</code> 即可访问 Web 服务。</p>

<h4 id="command">Command</h4>

<h5 id="gb-command">gb Command</h5>

<table>
<thead>
<tr>
<th align="left">Command</th>
<th align="center">功能</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">build</td>
<td align="center">编译包</td>
</tr>

<tr>
<td align="left">vendor</td>
<td align="center">调用 gb-vendor</td>
</tr>

<tr>
<td align="left">doc</td>
<td align="center">显示文档</td>
</tr>

<tr>
<td align="left">env</td>
<td align="center">打印项目的环境变量</td>
</tr>

<tr>
<td align="left">generate</td>
<td align="center">处理源代码生成Go文件</td>
</tr>

<tr>
<td align="left">info</td>
<td align="center">显示项目的信息</td>
</tr>

<tr>
<td align="left">list</td>
<td align="center">显示项目下的所有包</td>
</tr>

<tr>
<td align="left">test</td>
<td align="center">执行测试</td>
</tr>
</tbody>
</table>

<hr />

<h5 id="gb-vendor-parameter">gb vendor Parameter</h5>

<table>
<thead>
<tr>
<th align="left">Parameter</th>
<th align="center">功能</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">fetch</td>
<td align="center">获取一个远程依赖</td>
</tr>

<tr>
<td align="left">update</td>
<td align="center">更新一个本地依赖</td>
</tr>

<tr>
<td align="left">list</td>
<td align="center">每行一个列出所有依赖</td>
</tr>

<tr>
<td align="left">delete</td>
<td align="center">删除一个本地依赖</td>
</tr>

<tr>
<td align="left">purge</td>
<td align="center">清除所有未引用的依赖</td>
</tr>

<tr>
<td align="left">restore</td>
<td align="center">从manifest清单文件还原依赖</td>
</tr>
</tbody>
</table>

<blockquote>
<p>本文参考 tabalt 的 <a href="http://tabalt.net/blog/golang-package-dependency-management-tool-gb/">Golang包依赖管理工具gb</a> 一文。</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/C-Prefess-Program/">
        C Prefess Program Note
      </a>
    </h1>

    <span class="post-date">Sat, Jul 30, 2016</span>

    

<h1 id="c专家编程-笔记本">《C专家编程》 笔记本</h1>

<h3 id="c专家编程-是每一位程序员应该读的第二本c语言书籍">《C专家编程》是每一位程序员应该读的第二本C语言书籍！</h3>

<blockquote>
<p>讲了各种c的缺陷，推荐go用户好好体验，很多都在go里做了修正 —— [ggarlic]()</p>

<p>书很好，翻译一般，校对不负责任。</p>
</blockquote>

<ol>
<li><p><strong>新西兰</strong> 是关于时间编程的一个特殊地点；</p></li>

<li><p>编译器设计者的金科玉律 <strong>效率（几乎）就是一切</strong>；</p></li>

<li><p>B语言是 <strong>解释模式</strong> 语言，而C语言是 <strong>编译模式并引入了类型系统</strong> ，使效率大大提高；</p></li>

<li><p>C语言是为了 <strong>编译器设计者</strong> 而生的，这就是为什么很多编程语言在初期都是使用C语言编译器的原因；</p></li>

<li><p>为什么数组 <strong>下标从0开始</strong> ？</p>

<ul>
<li>在计算资源缺乏的过去，0标号的写法可以节省编译时间</li>
<li>现代语言中0标号可以更优雅的表示数组字串</li>
<li>在支持指针的语言中，标号被视作是偏移量，因此从0开始更符合逻辑</li>
</ul></li>

<li><p>将 <strong>常量放在比较表达式的前面</strong> 可以大大减少因打字出错将 <code>==</code> 输入为 <code>=</code> 的情况 <code>if(3 == x) {...}</code></p></li>

<li><p><strong>Bourne Shell</strong> 的出现促成了 The International Obfuscated C Code Competition（国际C语言混乱代码大赛）；</p></li>

<li><p><strong>ANSI C</strong> 美国国家标准化组织所定下的C语言标准；</p></li>

<li><p>语言律师 —— “可以从200多页的手册中提炼出5句话，并起来放到你面前，你只要一看就能明白自己问题答案的人”；</p></li>

<li><p>关键字 <code>const</code> 并不能把变量变成常量！在一个符号前面加上 <code>const</code> 只是表示这个符号不能被赋值，也就是变为 <strong>Read Only</strong> 。其最有用之处在于限定函数的形参，这样该函数将不会修改实参指针所指的数据，但其他的（没有用 <code>const</code> 的）函数却有可能修改它。</p></li>

<li><p>尽量不要在你的程序中使用 <strong>无符号类型</strong> ，以免增加不必要的复杂性。尤其是，不要仅仅因为其不存在负值（如年龄、 国债）而用它来表示数量。因为在某些情况下，会出现以下 BUG：</p>

<ul>
<li>-1 会被翻译成非常巨大的正整数。</li>
<li>-1 会比 1 大。</li>
</ul></li>

<li><p><code>malloc(strlen(str))</code> 几乎永远是错误的，因为 不要忘记还有 <code>'\0'</code> ；</p></li>

<li><p>NUL  用于结束有一个 ASCII 码零的正确术语；
NULL 用于表示什么都不指向；</p></li>

<li><p>如果需要使用一些临时变量的时候，请把它放在块的开始处！</p></li>

<li><p>缺省采用 &ldquo;Fall Through&rdquo;，在 <strong>97%</strong> 的情况下都是错误的！</p>

<pre><code class="language-c">// Fall Through : End without break;
switch (number) {
case 1: printf(&quot;case 1\n&quot;);
case 2: printf(&quot;case 2\n&quot;);
case 3: printf(&quot;case 3\n&quot;);
...
}
</code></pre></li>

<li><p>一种简单的方法，使一段代码第一次执行时的行为与以后的执行的行为不同；</p>

<pre><code class="language-c">generate_initializer(char * string) 
{
static char separator = ' ';
printf(&quot;%c %s\n&quot;, separator, string);
separator = ',';
}
</code></pre></li>

<li><p>重载之过：
```c
// 这是多少个乘号？
p = N * sizeof * q;
r = malloc(p);
// 答案：1个，sizeof操作符将指针q指向的东西作为操作数，它返回q所指对象的类型的字节数</p></li>
</ol>

<p>// 这是int的长度乘以p？还是把未知类型的指针强制转换为int？
apple = sizeof(int) * p;</p>

<pre><code>
18. 什么是 **结合性** ？

&gt; 在几个操作符具有相同优先级的时候决定先运行哪一个。

19. 为什么要使用 fgets() 而不是 gets() ？

20. 注释符缺陷：
```c
a //*
//*/ b
</code></pre>

<blockquote>
<p>means a/b in C but a in C++</p>
</blockquote>

<ol>
<li><p>早用line，勤用lint。当你做错事的时候，他会告诉你哪里不对，应该始终使用lint程序，按照它的道德标准办事。像使用 <code>go-lint</code> 一样写出优秀的代码。</p></li>

<li><p>将结构的声明与变量的定义分开可以使代码更加容易阅读：</p>

<pre><code class="language-c">struct veg { int weight, price_per_lb; };
struct veg onion, radish, turnip;
</code></pre></li>

<li><p><code>union</code> 与 <code>struct</code> 不同的是：</p></li>
</ol>

<blockquote>
<p>在内存布局中，struct 是将每个成员依次存储，而在 union 中，所有的成员都从偏移地址零开始存储。这样，每个成员的位置都重叠在一起：在某个时刻，只有一个成员真正存储于该地址。</p>

<p>所以 union 一般用于节省空间，因为 有些数据是不可能同时出现的，如果同时存储他们，显然颇为浪費。可以将互斥的两个字段存储于一个 union 中来节省空间：</p>
</blockquote>

<pre><code class="language-c">union secondary_characteristics {
    char has_fur;
    short num_of_leg_in_excess_of_4;
};
struct creature {
    char has_backbone;
    union secondary_characteristics form;
};
</code></pre>

<blockquote>
<p>这种方法在存储 2*10^7 只动物的时候可以节省 20MB 磁盘空间。</p>

<p>union 也可以将同一个数据解释成两个不同的东西：</p>
</blockquote>

<pre><code class="language-c">union bits32_tag {
    int whole;  /* 一个32位的值 */
    struct {char c0, c1, c2, c3; } byte; /* 4个8位的字节 */
} value;
</code></pre>

<ol>
<li><p><code>enum</code> 也就是 Golang 中的 <code>toao</code>：</p>

<pre><code class="language-c">enum sizes { small = 7, medium, large = 10, humungous };
// medium = 8 ; humungous = 11;
</code></pre></li>

<li><p>理解C语言声明的优先级规则</p>

<ul>
<li>A 声明从它的名字开始读取，然后按照优先级顺序依次读取。</li>
<li>B 优先级从高到低依次是：

<ul>
<li>1 声明中被括号括起来的那部分</li>
<li>2 后缀操作符：

<ul>
<li>括号 () 表示这是一个函数；</li>
<li>方括号 [] 表示这是一个数组；</li>
</ul></li>
<li>3 前缀操作符：星号 * 表示 “指向&hellip;的指针”</li>
</ul></li>
<li>C 如果 const 和（或）volatie 关键字的后面紧跟类型说明符（如int，long等），那么它作用于类型说明符。在其他情况下，const 和（或）volatie关键字作用于它左边紧邻的指针星号。</li>
</ul></li>
</ol>

<pre><code class="language-c">char * const *(*next) ();
</code></pre>

<blockquote>
<p>next 是一个指向函数的指针，该函数返回另一个指针，该指针指向一个只读的指向char的指针。</p>
</blockquote>

<ol>
<li>使字符串的比较看上去更自然：</li>
</ol>

<blockquote>
<p>strcmp() 函数用于比较两个字符串，当他们相等返回 0</p>
</blockquote>

<pre><code class="language-c">// 这看起来有点不符合语法
if(!strcmp(s, &quot;volatile&quot;)) return QUALIFIER;

// 也许我们可以这样做
#define STRCMP(a, R, b) (strcmp(a, b) R 0)
if(STRCMP(s, == , &quot;volatile&quot;))
</code></pre>

<ol>
<li><p>数组与指针的区别： <code>P102</code></p></li>

<li></li>
</ol>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/redigo-open2manyfiles/">
        redigo : open too many files
      </a>
    </h1>

    <span class="post-date">Wed, Jul 27, 2016</span>

    

<h1 id="redigo-panic-error-open-too-many-files">Redigo - panic error : open too many files.</h1>

<h3 id="abstract">Abstract</h3>

<p>今天对 <a href="https://www.github.com/HackeZ/getAcFunPage">getAcFunPage</a> 项目做 Benchmark 的时候发现了 Redis 会频繁报一个 <code>socket: too many open files</code> 的错误，后来发现并不是代码的问题，而是 Linux 的设置问题。
下面就来说说我是这么解决这个问题的。</p>

<h3 id="problem">Problem</h3>

<p>Benchmark 时报错内容截取如下：</p>

<pre><code>http: panic serving 127.0.0.1:53512: dial tcp :6379: socket: too many open files
goroutine 5322 [running]:
net/http.(*conn).serve.func1(0xc820f87f80)
    /usr/local/go/src/net/http/server.go:1389 +0xc1
panic(0x797240, 0xc820b12050)
    /usr/local/go/src/runtime/panic.go:426 +0x4e9
main.GetPageAndJSON(0x0, 0x0)
    /home/hackerzgz/workspace/golang/src/getAcFunPage/main.go:130 +0x20a
main.HandleGetResp(0x7f2103407500, 0xc8212fb450, 0xc8210a68c0)
    /home/hackerzgz/workspace/golang/src/getAcFunPage/main.go:82 +0x18
net/http.HandlerFunc.ServeHTTP(0x8902f0, 0x7f2103407500, 0xc8212fb450, 0xc8210a68c0)
    /usr/local/go/src/net/http/server.go:1618 +0x3a
net/http.(*ServeMux).ServeHTTP(0xc820015740, 0x7f2103407500, 0xc8212fb450, 0xc8210a68c0)
    /usr/local/go/src/net/http/server.go:1910 +0x17d
net/http.serverHandler.ServeHTTP(0xc82008a680, 0x7f2103407500, 0xc8212fb450, 0xc8210a68c0)
    /usr/local/go/src/net/http/server.go:2081 +0x19e
net/http.(*conn).serve(0xc820f87f80)
    /usr/local/go/src/net/http/server.go:1472 +0xf2e
created by net/http.(*Server).Serve
    /usr/local/go/src/net/http/server.go:2137 +0x44e
</code></pre>

<p>出现这个错误的时候， <code>webbench</code> 的参数为 <code>-c 300 -t 60</code> ，也就是并发300个客户端访问并持续60s。</p>

<p>由报错信息第一行中的 <code>dial tcp :6379</code> 很容易看出，这是由 Redis 所引起的错误。</p>

<h3 id="why">Why</h3>

<p>根据 <a href="http://stackoverflow.com/questions/19971968/go-golang-redis-too-many-open-files-error">Stack Overflow</a> 上的一个回答，这是由于 Linux 下设置的 <strong>文件描述符上限(file descriptors limit)</strong> 所引起的错误，在Ubuntu系统中，该值上限为 <strong>1024</strong> ，于是当 Redis 需要接收来自高并发所带来的连接请求时，连接数很有可能 <strong>超出文件描述符的上限值</strong> ，于是 Redis 就会报错了。</p>

<blockquote>
<p>文件描述符:<br />
内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。</p>
</blockquote>

<h3 id="solve">Solve</h3>

<p>要解决这个问题也很简单，只需要将服务器系统的文件描述符上限修改成一个更大的值即可：</p>

<pre><code class="language-shell">$ ulimit -n 99999
</code></pre>

<p>然后还需要对 Redigo 的连接池设置做出修改：</p>

<pre><code class="language-go">return &amp;redis.Pool{
		MaxIdle:     64,
		IdleTimeout: 3 * time.Second,
		MaxActive:   99999, // max number of connections
		...
}
</code></pre>

<p>编译，测试。终于不再报错了。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/why-handlefunc-called-twice/">
        Why HandleFunc Called Twice
      </a>
    </h1>

    <span class="post-date">Sun, Jul 24, 2016</span>

    

<h2 id="why-handlefunc-called-twice">Why <strong>HandleFunc()</strong> called twice?</h2>

<h3 id="abstract">Abstract</h3>

<p>今天遇到之前碰见过的一个问题，但是之前忘记研究了，正好今天终于把这个问题弄清楚了，于是记录下来。</p>

<p>想必很多做后台的小伙伴都写过服务器了，但是有没有遇到服务器在 <strong>通过不同的（Brower、API）方式访问</strong> 的时候，服务器响应方法的 <strong>次数</strong> 是不一样的情况呢？</p>

<h3 id="problem">Problem</h3>

<p>先来看看Golang中的简易服务器搭建代码：</p>

<pre><code class="language-go">func SayHello(rw http.ResponseWriter, req *http.Request) {
    io.WriteString(rw, &quot;hello~ You are in!&quot;)
    log.Println(&quot;Oh, Here is a Guy coming in!&quot;)
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc(&quot;/&quot;, SayHello)
    http.ListenAndServe(&quot;:8080&quot;, mux)
}
</code></pre>

<p>这是一个最简单的Golang服务器搭建，当http访问 <code>http://hackez.github.io:8080</code> 的时候，该服务器会对客户端返回 <code>hello~ You are in!</code> ，同时在服务器控制台中打印 <code>Oh, Here is a Guy coming in!</code> 。</p>

<p>有意思的部分来了：</p>

<blockquote>
<p>通过 <strong>Brower</strong> 访问的时候，服务器控制台会打印出 <strong>两行</strong> <code>Oh, Here is a Guy coming in!</code>。</p>

<p>通过 <code>curl http://hackez.github.io:8080</code> 命令进行访问的时候，服务器控制台只会打印 <strong>一行</strong> <code>Oh, Here is a Guy coming in!</code>。</p>
</blockquote>

<h2 id="why">Why</h2>

<p>为什么会出现那么有趣的问题呢？<a href="http://stackoverflow.com/questions/33432192/handlefunc-being-called-twice">StackOver</a>上也有人问了这个问题，原因出现在 Brower 上，通过打印 <code>requsets</code>，你会发现 Brower 还会发起二次请求去请求 <code>/favicon.ico</code>，也就是页面的小图标。</p>

<p>所以这就是用 <code>CURL</code> 发起请求的时候，并不会出现二次请求的原因！</p>

<h2 id="solve">Solve</h2>

<p>既然知道了这个问题出现在哪，剩下就好办了，既然浏览器要请求图标，那么我们就在写一个路由专门处理这个请求即可：</p>

<pre><code class="language-go">func main() {
    mux := http.NewServeMux()
    mux.HandleFunc(&quot;/&quot;, SayHello)
    // Handle /favicon.ico
    mux.HandleFunc(&quot;/favicon.ico&quot;, func(rw http.ResponseWriter, req *http.Request) {})
    http.ListenAndServe(&quot;:9000&quot;, mux)
}
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/golang-dev-log/">
        Golang Dev Log
      </a>
    </h1>

    <span class="post-date">Sat, Jul 23, 2016</span>

    

<h2 id="golang-dev-log">Golang Dev Log</h2>

<hr />

<p>今天快要把 <a href="https://www.github.com/HackeZ/getAcFunPage">getAcFunPage</a> 这个项目完结了，结果在重构项目的时候出现了两个哭笑不得的 <strong>BUG</strong> 。总结下来，都是因为自身对 Golang 认识不够深入而出现的问题，所以现在这篇 Blog 是专门记录我在Golang开发中遇到的需要注意的点，以此警醒自己！</p>

<ol>
<li>一个通用的结构体应该以一个包的方式存在并进行引用，否则会出现同一个结构体在不同的包中声明之后，在调用的时候，编译器会报 <code>cannot use xxx (type user) as type School.user</code> 的错误。</li>
</ol>

<pre><code class="language-go">// Example 1

// file main.go
type user struct {
    name     string
    age      int64
}

// file school.go
type user struct {
    name     string
    age      int64
}
</code></pre>

<ol>
<li>如果一个函数需要使用一个 <strong>相对路径</strong> 调用一个 <code>静态文件</code> ，那么需要将这个 <code>静态文件</code> 的路径作为参数进行传入。<br />
因为 Golang 中对于 <code>静态文件</code> 的调用不是根据函数所在位置的 <strong>相对路径</strong> ，而是取决于调用这个函数的文件的位置所对应的相对路径。</li>
</ol>

<pre><code class="language-go">// Example 2

// ./markdown/markdown-style.go (Wrong)
func GetStyle() {
    f, err := os.OpenFile(&quot;./markdown-style.css&quot;,...)
}

// ./markdown/markdown-style.go (Corrent)
func GetStyle(filepath string) {
    f, err := os.OpenFile(filepath,...)
}

// ./main.go
func main() {
    // Wrong:  The system cannot find the file specified.
    md.GetStyle()

    // Corrent
    md.Corrent(&quot;./markdown/markdown-style.css&quot;)
}
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/redigo-action-1/">
        Redigo Action - 1
      </a>
    </h1>

    <span class="post-date">Fri, Jul 22, 2016</span>

    

<h1 id="redigo-action">Redigo Action</h1>

<h4 id="redis-作为一个内存型的高性能数据库-如今是越来越火了-为了得到更高的-qps-以及-tps-我们无法忽视掉这个如此强大的数据库">Redis 作为一个内存型的高性能数据库，如今是越来越火了，为了得到更高的 QPS 以及 TPS ，我们无法忽视掉这个如此强大的数据库。</h4>

<h4 id="在-redis-官网中-golang语言的-框架-http-redis-io-clients-go-有两个是被官方所推荐的-分别为">在 Redis 官网中，Golang语言的<a href="http:redis.io/clients#go">框架</a>有两个是被官方所推荐的，分别为：</h4>

<p><strong>1. <a href="https:github.com/garyburd/redigo">Redigo</a></strong>
<strong>2. <a href="https:github.com/mediocregopher/radix.v2">Radix</a></strong></p>

<h4 id="本着源码易读优先-我选择了-redigo-进行开发尝试-项目地址-点我-https-www-github-com-hackez-getacfunpage">本着源码易读优先，我选择了 Redigo 进行开发尝试，项目地址<a href="https:www.github.com/HackeZ/getAcFunPage">点我</a>。</h4>

<h3 id="action">Action</h3>

<p>熟悉Redis的同学都知道，Redis是 <strong>单进程，单线程，IO多路复用</strong> 的，这一点不同于 MySQL 的多线程。
 这就意味这Redis可以使用长连接来进行通信，那么，我们就需要一个连接池去管理这些长连接，当一个长连接使用完毕之后就可以交给下一个长连接继续进行使用。</p>

<blockquote>
<p><strong>连接池</strong>
基本思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。
而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。
也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</p>
</blockquote>

<p>而 Redigo 就是支持连接池的，看看 <a href="https:github.com/garyburd/redigo/blob/master/redis/pool.go#L43">Redigo - Pool</a>.
其 L43 ～ L92 就给出了一个完整的 连接池 的正确打开方式。</p>

<pre><code class="language-go">func newPool(server, password string) *redis.Pool {
      return &amp;redis.Pool{
          MaxIdle: 3,
          IdleTimeout: 240 * time.Second,
          Dial: func () (redis.Conn, error) {
            c, err := redis.Dial(&quot;tcp&quot;, server)
            if err != nil {
                return nil, err
            }
            if _, err := c.Do(&quot;AUTH&quot;, password); err != nil {
                c.Close()
                return nil, err
              }
               return c, err
          },
          TestOnBorrow: func(c redis.Conn, t time.Time) error {
              _, err := c.Do(&quot;PING&quot;)
              return err
          },
      }
  }
</code></pre>

<p>这段简单易懂的代码返回了一个可用的 Redis 连接池，为了能够进行长连接处理，我们还需要定义一个全局的 <strong>redis.Pool</strong> 变量进行使用。</p>

<pre><code class="language-go">  var (
      pool *redis.Pool
      redisServer = flag.String(&quot;redisServer&quot;, &quot;:6379&quot;, &quot;&quot;)
      redisPassword = flag.String(&quot;redisPassword&quot;, &quot;&quot;, &quot;&quot;)
  )

  func main() {
      flag.Parse()
      pool = newPool(*redisServer, *redisPassword)
      ...
  }
</code></pre>

<p>当 <strong>request请求</strong> 来到，我们就可以这样进行获取连接，并且一定记得在使用完毕之后将连接放回连接池。</p>

<pre><code class="language-go">   func serveHome(w http.ResponseWriter, r *http.Request) {
       conn := pool.Get()
       defer conn.Close()
       ....
   }
</code></pre>

<h5 id="到了这里-一个可用并且高性能的-redis-数据库的连接已经基本构建完毕了">到了这里，一个可用并且高性能的 Redis 数据库的连接已经基本构建完毕了！</h5>

<h5 id="接下来就可以愉快地进行使用了">接下来就可以愉快地进行使用了～</h5>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/cold-start/">
        Cold Start
      </a>
    </h1>

    <span class="post-date">Wed, Jul 13, 2016</span>

    

<h1 id="about-two-different-cold-start">About Two Different Cold Start</h1>

<h2 id="app-cold-start">APP Cold Start</h2>

<hr />

<h2 id="what-s-app-cold-start"><strong>What&rsquo;s App Cold Start</strong></h2>

<blockquote>
<p>对于最近安装的App a，我们不可能得到该对于该App用户的特殊使用信息。尤其是打开该App的概率 P(a)。另一方面，对于给定的 feature（特征）的先验概率（指根据以往经验和分析得到的概率），可以从其他用户的信息中获取。</p>

<p>因此，对于最近安装的App，怎么估计其打开概率P(a)是至关重要的。</p>
</blockquote>

<h2 id="yahoo-s-experimental-result"><strong>Yahoo&rsquo;s Experimental Result</strong></h2>

<p>通过记录最近安装的App打开记录（活跃度），图5（Daily）以及图6（Hourly）：</p>

<p><img src="http://7xsxev.com1.z0.glb.clouddn.com/Days-after-installation.png" alt="Days After Installation" /></p>

<p>图 5  日常App安装后的活跃度</p>

<p><img src="http://7xsxev.com1.z0.glb.clouddn.com/Days-after-installation.png" alt="Hours After Installation" /></p>

<p>图 6  每小时App安装后的活跃度</p>

<p>从图 5 和 6 中可以看到，最近安装的App一个显着的特点是在安装后的数小时内非常活跃。但是经过这段时间之后，最近安装的App 的活跃度显着减少。与此相反，一些一开始活跃度并不高的 App 经常在它们安装后的很长一段时间依然在使用。</p>

<h2 id="to-solve-app-cold-start"><strong>To Solve App Cold Start</strong></h2>

<p>因此，为了更好地获取最近安装App打开频率，我们根据它们的活跃度持续时间长短，定义两种App类型，分别为：</p>

<ol>
<li>Short-term （活跃度持续时间短，在刚开始的一段时间活跃度很高）</li>
<li>Long-term（活跃度持续时间长，在刚开始的一段时间活跃度不够高）</li>
</ol>

<p>为捕抓每个App在时间上的突出显著性，我们将App使用数据转化为 <strong>Beta(α,β)</strong> 值，为了区分时间显著性，我们使用尖峰（excess kurtosis）δ来评价每个App的时间使用峰度：
<img src="http://7xsxev.com1.z0.glb.clouddn.com/Excess-kurtosis-expression.png" alt="Excess Kurtosis Expression" /></p>

<p>通过尖峰值可以判断最近安装App的类型：</p>

<ul>
<li>一个高尖峰值的App意味着它越有可能是Short-term类App（Game）</li>
<li>一个低尖峰值的App意味着它越有可能是Long-term类App（Communication）</li>
</ul>

<p><strong>Short-term类的App可以通过获取特定的特点的用户来获取平均打开频率。</strong><br />
<strong>Long-term类的App则可以通过获取所有用户的平均值。</strong></p>

<p>随着用户打开App的事件增加，我们可以计算最近安装App的打开概率，因此，我们使用贝叶斯平均其他用户的历史信息来计算接下来的使用信息。计算最近安装App的打开概率公式如下：</p>

<p><img src="http://7xsxev.com1.z0.glb.clouddn.com/App-cold-start-expression.png" alt="App Cold Start Expression" /></p>

<p>通过计算公式，仅仅通过少量的用户打开App事件得到同一App的其他用户近似的非加权值的启动概率。<strong>用户打开App事件越多，该公式的准确率越高。</strong></p>

<hr />

<h2 id="user-cold-start">User Cold Start</h2>

<h2 id="what-s-user-cold-start"><strong>What&rsquo;s User Cold Start</strong></h2>

<blockquote>
<p>在这一小节，我们提出两种方法解决User冷启动问题，什么是User冷启动呢？
当一个用户安装了一个Launcher软件（Aviate，Buzz，Go 等桌面软件），我们在不知道这个用户的任何信息下如何向该用户推荐App清单呢？这个就是User冷启动问题。</p>
</blockquote>

<h2 id="two-ways-to-solve"><strong>Two Ways to Solve</strong></h2>

<ol>
<li><p>最相似用户策略：
当这个new User在安装了Launcher之后，我们可以在已知的用户集中找到跟他最相似的用户，并将这个用户的使用指标赋值给他。<br />
那么怎么去计算跟他最相似的用户呢，我们可以使用 <strong>Jaccard系数</strong> 进行计算，这个系数主要用来比较样本集中的相似性和分散性的一个概率。<br />
<strong>计算出用户之间的相似度，就可以将最相似用户的App清单进行推送。</strong><br />
事实上，最相似的用户的App清单与新用户的清单还是有很大的不一样的，在极端条件下，也就是不涉及到敏感的用户信息条件下，他们之间的App清单相似度甚至不会超过一个 <strong>纯粹随机策略</strong> （相当于“猴子排序”）。<br />
虽然这个策略提高了User冷启动的平均准确度，但是也限制了可生成用户建议数的范围。</p></li>

<li><p>伪用户策略：
通过生成“伪历史”（假的用户使用记录）可以解决用户冷启动问题，而且该策略可以作为新用户训练PTAN模型的一种方法。<br />
这个想法在于找到少量的相似用户，其App清单能够覆盖新用户的App清单。这是一个简单的 <strong>NP-Hard证明问题</strong> 。</p></li>
</ol>

<blockquote>
<p>P.S 1: NP-Hard问题也就是不能在限定的时间内计算出结果的问题，只能通过候选答案来验证这个答案是不是我们已知问题的一个答案</p>

<p>P.S 2关于这个问题为什么是一个NP-Hard问题，论文中没有给出解释，如果想了解怎么判断一个问题是不是NP-Hard问题，可以到 <a href="http://blog.csdn.net/com_stu_zhang/article/details/7248277">这里</a> 查看解释，因为解释非常复杂，请允许我不复制粘贴上来</p>
</blockquote>

<p>通过算法5，我们生成了伪用户数据：
<img src="http://7xsxev.com1.z0.glb.clouddn.com/Build-pseudo-user.png" alt="Build Pseudo User" /></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/hadoop-1/">
        Learning in Hadoop - Day 1
      </a>
    </h1>

    <span class="post-date">Mon, Jun 13, 2016</span>

    <p>第一次玩Hadoop</p>

<p>最近在折腾机器学习，因为查阅到Yahoo的</p>

<blockquote>
<p>《Predicting The Next App That You Are Going To Use》</p>
</blockquote>

<p>这一篇Paper的时候，它提到了Google的 <strong>MapReduce</strong>以及 <strong>Word2Vec</strong> 。相信折腾过机器学习的小伙伴都会比较熟悉这两个东西了。于是，为了更深入地进行学习，我便无情地掉进了这个 <strong>坑</strong> 里。</p>

<p>首先介绍一下背景，Yahoo的这篇Paper主要就是根据用户日常APP的使用习惯，然后对用户下一启动的APP进行预测。因为Yahoo认为日常手机的使用场景会对哪个APP的开启与否有着很强的关联性，于是他们便使用了 <strong>Word2Vec</strong> 对用户手机中记录的6个手机事件：</p>

<ol>
<li><em>Last Location Update</em></li>
<li><em>Last Charge Cavle</em></li>
<li><em>Last Audio Cable</em></li>
<li><em>Last Context Trigger</em></li>
<li><em>Last Context Pulled</em></li>
<li><em>Last App Open</em></li>
</ol>

<p>进行计算词向量，用于文本预测。而Word2Vec有着3个广为流传的版本：</p>

<ol>
<li>C</li>
<li>Python</li>
<li>Java</li>
</ol>

<p>但是这3个版本对于Yahoo来说性能都是不足的，经我测试，一个800M的文本在C语言版本中计算时间需要20Min！</p>

<p>而在预测下一个APP这个场景里，这种计算速度是完全不可以接受的，于是Yahoo他们利用MapReduce重写了一个Word2Vec，将这个版本放在云端进行计算。这就是我进行MapReduce学习的原因。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/lenproblem/">
        Named Question in Golang
      </a>
    </h1>

    <span class="post-date">Thu, Jun 2, 2016</span>

    <p>Golang中遇到的命名问题</p>

<p>昨天在写随机生成字符串代码时候遇到了一个Golang的命名问题，代码如下：</p>

<pre><code class="language-go">func GetRandomString(len string) string {
    str := &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
    bytes := []byte(str)
    result := []byte{}
    r := rand.New(rand.NewSource(time.Now().UnixNano()))

    for i := 0; i &lt; len; i++ {
        result = append(result, bytes[r.Intn(len(str))]) // &lt;- Here is the Problem: `cannot call non-function len (type int)`
    }
    return string(result)
}
</code></pre>

<p>这个问题太蛋疼了，之前好像从来没遇到过这个问题，而且Google好像也没有找到相关的问题原因。</p>

<p>后来一步步排查代码，才发现问题原来是出现在：</p>

<blockquote>
<p>for i := 0; i &lt; <strong>len</strong>; i++ {</p>
</blockquote>

<p>中的 <strong>len</strong> 变量与函数 <strong>len()</strong> 重复而出现的命名错误，所以只需要将 <strong>len</strong> 变量重新命名即可解决该问题。</p>

<p>总结：在Golang中使用的变量一定不要和某个函数名字相同，否则不会通过，我现在暂时不清楚是Golang编译器出现的问题，还是Golang本来就不允许这样写，我会继续查阅相关文档查清楚！</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/channel/">
        The Channel in Golang
      </a>
    </h1>

    <span class="post-date">Wed, May 11, 2016</span>

    

<p>Golang中的Channel分析</p>

<p>作为Golang语言的核心，并发编程是学习Golang的必经之路。对于不同进程之间的通信手段总会涉及到跨进程通信，那么这个通信手段必须是一个可共享内存的方法，而Golang提倡的理念为：</p>

<blockquote>
<p>“应该以通信作为手段来共享内存”</p>
</blockquote>

<p>而这一句话的直接体现在于Golang所提供的一个预定义数据类型 —— <strong>Channel</strong></p>

<p>Channel提供了一种机制。它既可以 <strong>同步</strong> 两个被并发执行的函数，又可以让这两个函数通过传递特定类型的值来进行 <strong>通信</strong>。使用Channel可以让我们编写更清晰且正确的代码。</p>

<p>关于使用Channel需要记住的知识点：</p>

<ul>
<li>在同一时刻，仅有一个Goroutine能向同一个Channel发送元素值，同时也只有一个Goroutine能从它哪里接收元素值。</li>
<li>Channel是一个FIFO的消息队列。</li>
<li>Channel中的元素值已经确保具有原子性。</li>
<li>Channel可以分为缓冲与非缓冲，它们之间的差别非常大。</li>
<li>Channel可分为双向与单向，一般通道都会声明为双向，只有在限制函数体中使用通道的方式（只允许发送或接收）才会使用单向Channel。</li>
</ul>

<h2 id="talk-is-cheap-show-me-the-code">Talk is Cheap,Show me the Code!</h2>

<ul>
<li>初始化通道</li>
</ul>

<p>因为Channel属于引用类型之一，所以必须使用make关键字初始化它。</p>

<pre><code class="language-go">// 缓冲通道（容纳int类型元素，有长度，可暂存元素）
intChan := make(chan int, 5)

// 非缓冲通道（容纳byte类型元素，无长度，不可暂存元素）
byteChan := make(chan byte)
</code></pre>

<ul>
<li>发送元素值</li>
</ul>

<pre><code class="language-go">// 向intChan通道发送一个元素值为5的元素
intChan &lt;- 5
</code></pre>

<p>注意：向一个值为nil的Channel进行发送操作会造成当前Goroutine <strong>永久阻塞！</strong>。<br />
而向一个已经塞满元素的Channel进行发送操作则会将当前的Goroutine <strong>阻塞</strong>，直至Channel中的元素被接收，所以一般会在 <strong>select</strong> 代码块中进行发送操作。</p>

<ul>
<li>接收元素值</li>
</ul>

<pre><code class="language-go">// 在intChan通道中接收一个元素值
elem := &lt;-intChan

// 接收元素值，并判断该通道是否已经关闭
elem, ok := &lt;-intChan
if !ok {
    fmt.Println(&quot;Channel is Closed!&quot;)
}
</code></pre>

<p>同样需要注意的是，如果向一个值为nil的Channel进行接收操作，同样会造成 <strong>永久阻塞！</strong><br />
而向一个没有元素值的Channel进行接收操作，也会将当前的Goroutine <strong>阻塞</strong>，直至Channel中有了新的元素。</p>

<ul>
<li>关闭Channel</li>
</ul>

<p>关闭Channel并不是如其字面意思，完全将Channel关闭。而其正确的作用是告诉系统，不应该再允许任何针对被关闭的通道的发送操作，该通道已经被关闭，但是已经缓存在Channel中的元素不会受到影响，这也是Channel非常优秀的特性之一。</p>

<pre><code class="language-go">// 调用内建函数close()关闭Channel
close(intChan)
</code></pre>

<p>注意，无论任何时候，我们都 <strong>不应该</strong> 在接收端关闭Channel，因为我们永远都不知道发送端是否已经将元素发送完毕。</p>

<hr />

<blockquote>
<p>最后，可以到<a href="https://www.github.com/HackeZ">这里</a>学习更多的Channel相关代码！</p>
</blockquote>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/socket/">
        socket
      </a>
    </h1>

    <span class="post-date">Tue, May 3, 2016</span>

    

<h1 id="socket-study">Socket Study</h1>

<hr />

<h2 id="what-is-socket">What is Socket</h2>

<p>Socket(插座) 作为 UNIX的进程通信机制，一般被通称为</p>

<blockquote>
<p>套接字</p>
</blockquote>

<p>用于描述IP地址和端口，是一个通信链的句柄。</p>

<p>在Internet上的主机一般会运行多个服务软件，同时提供多个服务，每个服务都打开一个Socket，并绑定在一个端口上，不同端口对应不同的服务。</p>

<hr />

<p>正如其英文意思 —— 插座，Socket在不同端口提供着不同的服务，互相之间互不干扰，你只需要将插头插入正确的插座，就可以得到你想要的服务了。</p>

<h2 id="socket通讯过程">Socket通讯过程</h2>

<p>Socket类似于电话插座，电话的通话双方相当于互相通信的2个进程，区号是它的网络地址；区内一个单位的交换机相当于一台主机，主机分配给每个用户的局内号码相当于socket号。</p>

<ul>
<li>任何用户在通话之前，首先要<strong>占有一部</strong>电话机，相当于申请一个socket；</li>
<li>同时还要知道对方的号码，相当于对方有一个固定的的socket地址；</li>
<li>然后向对方拨打电话，相当于发出连接请求<strong>（假如对方不在同一个区内，还要添加区号，相当于给出网络地址）</strong>；</li>
<li>这时候，如果对方在场并且空闲，相当于通信的另一个主机开机且可以接受连接请求；</li>
<li>对方拿起电话，双方就可以正式通话，相当于<strong>连接成功</strong></li>
<li>双方通话的过程，是一方向电话机发出信号和对方电话机接收信号的过程，相当于向socket发送数据以及接收数据；</li>
<li>通话结束后，一方挂起电话相当于关闭socket，撤销连接；</li>
</ul>

<h2 id="socket-协议">Socket 协议</h2>

<p>Socket协议：（协议，本地地址，本地端口）<br />
一个完整的socket有一个本地唯一的socket号，由<strong>操作系统进行分配</strong>
最重要的是，socket是<strong>面向客户/服务器模型</strong>而设计的，针对客户和服务器程序提供不同的socket系统调用：</p>

<ul>
<li>客户可以随机申请一个socket，相当于一个想打电话的人可以在任何一台入网电话上拨号呼叫，系统会为之分配一个socket号；</li>
<li>但是服务器拥有的是全局公认的socket，任何客户都可以向它发出连接请求和信息请求，相当于一个被呼叫的电话拥有一个呼叫方知道的电话号码。</li>
</ul>

<p>Socket利用<strong>客户/服务器模式</strong>巧妙地解决了通信之间建立通信连接的问题，服务器socket半相关被全局公认这一概念非常重要。</p>

<hr />

<p>我们不妨考虑一下，两个<strong>完全随机</strong>的用户进程之间如何建立通信？假如通信双方没有任何一方的固定socket，就好比打电话的双方不知道彼此的电话号码，要通信是<strong>不可能的</strong>。</p>

<h2 id="socket-api">Socket API</h2>

<p>在Java中，Socket API：
&gt; java.net.Socket 继承于 java.lang.Object</p>

<p>它有<strong>八个构造器</strong>，方法并不多，下面介绍频繁使用的三个方法：</p>

<ul>
<li>Accept</li>
</ul>

<p>该方法用于产生“阻塞”，直到接收到一个连接，并且返回一个客户端的socket对象实例。</p>

<blockquote>
<p>阻塞 —— 它使程序运行暂时“停留”在这个地方，直到会话产生，然后程序继续。通常的“阻塞”都是由循环产生的。</p>
</blockquote>

<ul>
<li>getInputStream</li>
</ul>

<p>该方法获得网络连接输入，同时返回一个InputStream实例，通过该实例可以传输byte字节流。</p>

<ul>
<li>getOutStream</li>
</ul>

<p>该方法连接的是另一端得到输入，同时返回一个OnputSteam，该实例可以得到输入传输的byte字节流。</p>

<blockquote>
<p>注意：其中 getInputStream 以及 getOutStream 方法均可能产生一个 IOException，它必须被捕获，通常都会被另一个流对象使用。</p>
</blockquote>

<h2 id="socket连接过程">Socket连接过程</h2>

<p>根据连接启动方式以及本地socket连接的目标，socket之间的连接过程可以分成三个步骤：</p>

<ul>
<li>服务器监听</li>
<li>客户端请求</li>
<li>连接确认</li>
</ul>

<p><strong>服务器监听</strong>：是服务器端的socket并不定位具体的客户端socket，而是处于<strong>等待连接</strong>的状态，实时监控网络状态。</p>

<p><strong>客户端请求</strong>：是指客户端的socket提出连接请求，要连接的目标是服务器端的socket，为此，客户端socket必须要描述清楚它要连接的服务器socket，支出该服务器端socket的<strong>地址</strong>以及<strong>端口</strong>，然后就想服务器socket提出连接请求。</p>

<p><strong>连接确认</strong>：是指当服务器端socket监听到或者说是接收到客户端socekt的连接请求，它就响应客户端socket的请求，建立一个新的进程，把服务器端socket的<strong>描述</strong>发给客户端，一旦客户端<strong>确认了此描述</strong>，连接就建立好了。而服务器端socket继续处于监听状态，继续等待其他客户端socket的连接请求。</p>

<p>Socket UDP &amp;&amp; TCP</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/qn-sdkv7-pb/">
        Qiniu Go SDK v7 Problem
      </a>
    </h1>

    <span class="post-date">Fri, Apr 15, 2016</span>

    <p>下载七牛Go SDK v7遇到的问题</p>

<p>今天想要使用七牛的Go SDK时候遇到了肯定会出现的一个情况，那就是</p>

<blockquote>
<p>$ go get -u qiniupkg.com/api.v7</p>
</blockquote>

<p>命令出现了</p>

<blockquote>
<p>golang.org/x/net/context</p>
</blockquote>

<p>不能下载的问题，首先说一下为什么肯定会报错的问题，那就是Go官方将这个包的下载地址更改了（后来翻墙到Go官网发现的），但是不知道为什么go get命令还是将这个包的下载地址设置为原来的那个。
好吧，于是我试着使用七牛提供的方法下载了那个压缩包，并将其解压在</p>

<blockquote>
<p>$GOPATH/src</p>
</blockquote>

<p>目录下，再次运行go get 命令，这时候出现了</p>

<blockquote>
<p>golang.org/x/net/content is not using a known version</p>
</blockquote>

<p>的错误。
无奈之下，只有翻墙出去Go官方网站查看文档了，然后发现Go官方将这个<a href="https://github.com/golang/net">net包</a>放在了Github中，于是我在Github中下载下来这个包，然后在</p>

<blockquote>
<p>$GOPATH/src</p>
</blockquote>

<p>下，也就是Github.com文件夹的平级目录下手动创建了该路径</p>

<blockquote>
<p>&hellip;/golang.org/x</p>
</blockquote>

<p>，然后将net包放进去，再次运行</p>

<blockquote>
<p>$ go get -u qiniupkg.com/api.v7</p>
</blockquote>

<p>OK，成功了，接下来就可以开始愉快地玩耍了:)</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/build/">
        本篇将教会你如何使用Hugo快捷地在Github中创建自己的Blog
      </a>
    </h1>

    <span class="post-date">Wed, Apr 13, 2016</span>

    

<h2 id="安装hugo">安装Hugo</h2>

<hr />

<p>Hugo是一个使用Golang语言编写的静态Web站点生成框架，其是由Docker前员工Steve Francia进行编写的，因为其开源在Github里，所以安装非常方便，我们可以选择二进制安装包进行安装。安装完成之后可以运行以下命令查看是否正确安装：</p>

<blockquote>
<p>$ hugo version</p>
</blockquote>

<p>正确安装应该会出现如下信息：</p>

<blockquote>
<p>Hugo Static Site Generator v0.14 BuildDate: 2015-05-26T09:29:16+08:00</p>
</blockquote>

<p>接下来就可以愉快地开始Hugo之旅了。</p>

<h2 id="创建hugo项目">创建Hugo项目</h2>

<hr />

<p>创建Hugo项目可以使用如下命令</p>

<blockquote>
<p>$ hugo new site &lt;site-name&gt;</p>
</blockquote>

<p>这样在该目录下就会出现这个项目文件夹了。
我们 cd 进入该目录，可以看到该目录下有一个名为：</p>

<blockquote>
<p>config.toml</p>
</blockquote>

<p>的文件，根据其名字很容易就知道这个就是Hugo的站点的配置文件了。
该文件中仅仅只有3行代码：</p>

<blockquote>
<p>baseurl = &ldquo;<a href="http://replace-this-with-your-hugo-site.com/&quot;">http://replace-this-with-your-hugo-site.com/&quot;</a>
languageCode = &ldquo;en-us&rdquo;<br />
title = &ldquo;My New Hugo Site&rdquo;</p>
</blockquote>

<p>同样也是根据其单词我们也可以知道他们代表的是什么，我们可以对title进行一下修改，改为我们Blog的名字。</p>

<p>然后我们在该目录下运行命令：</p>

<blockquote>
<p>$ hugo server</p>
</blockquote>

<p>这个命令会将repo转换成静态html文件放入项目的public文件夹下，然后通过访问浏览器的</p>

<blockquote>
<p><a href="http://hackez.github.io:1313">http://hackez.github.io:1313</a></p>
</blockquote>

<p>地址，即可看到Hugo启动起来了。虽然现在站点是空白一片，但是通过添加Hugo主题，我们可以瞬间建立一个完整Blog站点。</p>

<h2 id="选取hugo主题">选取Hugo主题</h2>

<hr />

<p>我们可以到Hugo官网选取自己喜欢的<a href="http://themes.gohugo.io/">主题</a>
下面我以Hyde主题为例，将该主题应用到自己的Blog中。</p>

<p>首先在站点的根目录下创建一个 themes 文件夹。</p>

<blockquote>
<p>$ mkdir themes<br />
$ cd themes<br />
$ git clone <a href="https://github.com/spf13/hyde.git">https://github.com/spf13/hyde.git</a>  #下载对应主题</p>
</blockquote>

<p>然后，我们需要对根目录下的</p>

<blockquote>
<p>config.toml</p>
</blockquote>

<p>进行配置，以应用下载下来的主题。</p>

<p>配置完成的文件如下所示：</p>

<pre><code class="language-toml">baseurl = &quot;http://replace-this-with-your-hugo-site.com/&quot;
languageCode = &quot;en-us&quot;    
title = &quot;HackerZ - Blog&quot;    
theme = &quot;hyde&quot;   # 指定themes

[params]    
	description = &quot;Welcome to my personal Blog&quot;   # hyde主题的首页描述 
	themeColor = &quot;theme-base-08&quot;  # 指定hyde的主题颜色
</code></pre>

<p>这样，主题就算是配置好了，让我们再次运行</p>

<blockquote>
<p>$ hugo server</p>
</blockquote>

<p>看看效果吧！</p>

<h2 id="新建文章">新建文章</h2>

<hr />

<p>首页以及样式都已经有了，那么下面就来看看怎么新建一篇文章吧。</p>

<p>在站点项目下运行</p>

<blockquote>
<p>$ hugo new welcome.md</p>
</blockquote>

<p>即可看到在项目的content目录下被创建了一个 welcome.md 文件，该文件就是刚才新建出来的文章了。
我们可以往里面写点东西，注意，这是 markdown 格式的，hugo会将其编译成 html 格式放置在 public 目录下。</p>

<blockquote>
<p>welcome.md</p>

<pre><code>+++    
Categories = [&quot;Development&quot;, &quot;GoLang&quot;]    
Description = &quot;&quot;    
Tags = [&quot;Development&quot;, &quot;golang&quot;]    
date = &quot;2016-03-29T14:38:19+08:00&quot;    
menu = &quot;main&quot;    
title = &quot;Welcome&quot;    

+++

### 
这是使用Hugo创建的站点中的第一篇文章。
</code></pre>

<p>然后启动Hugo服务查看效果吧。</p>

<p>$ hugo server</p>
</blockquote>

<p>到这里，基本的Hugo使用已经讲解完毕了，接下来就要将该静态站点迁移到我们自己的 github.io 中了。</p>

<h2 id="使用github-pages">使用Github Pages</h2>

<p>要使用 github-pages 首先需要注册属于自己的 github 账号，注册完成之后，创建一个 repository，名为</p>

<blockquote>
<p>&lt;USERNAME&gt;.github.io</p>
</blockquote>

<p>这个是使用 Github Pages 的命名规定，如我自己就是</p>

<blockquote>
<p>HackeZ.github.io</p>
</blockquote>

<p>创建完成之后，在我们已经写好的Hugo站点下修改配置文件中的 baseurl属性：</p>

<blockquote>
<p>config.toml</p>

<pre><code>baseurl = &quot;http://&amp;lt;USERNAME&gt;.github.io//&quot;
# baseurl = &quot;http://replace-this-with-your-hugo-site.com/&quot;
# 原baseurl可以将其注释掉，之后本地可以进行调试
</code></pre>

<p>保存后，运行如下命令：</p>

<p>$ hugo -v</p>
</blockquote>

<p>该命令会将配置文件中的参数进行静态文件编译，运行完之后，可以到public下的 index.html 中看看静态文件的地址是否是有误，如果有误，将不能正确地显示出主题样式。</p>

<p>一切正确之后，我们以public目录为 &lt;USERNAME&gt;.github.io 项目的主分支，将其 push 到 github仓库中，等待10分钟左右，访问属于你自己的Blog网站吧！</p>

<blockquote>
<p>http://&lt;USERNAME&gt;.github.io</p>
</blockquote>

<h2 id="配置属于自己的hugo主题">配置属于自己的Hugo主题</h2>

<p>你们可以看到，我已经对原来的Hyde主题进行了修改了，那么是怎么做到的呢，我们可以直接对 themes/hyde 下的配置文件进行修改，增加自己想要的样式，相信聪明的你肯定可以很快熟悉 Hugo 的语法，创建属于自己的主题。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://hackez.github.io/welcome/">
        Welcome
      </a>
    </h1>

    <span class="post-date">Tue, Mar 29, 2016</span>

    <p>这是使用Hugo创建的站点中的第一篇文章，我是HackerZ。</p>

<p>如果你想知道如何使用Hugo搭建这样一个Blog的话，可以看看<a href="http://hackez.github.io/build">这里</a>。</p>

  </div>
  
</div>
</div>

  </body>
</html>
