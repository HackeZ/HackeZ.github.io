<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on HackerZ - Blog</title>
    <link>http://localhost/categories/golang/index.xml</link>
    <description>Recent content in Golang on HackerZ - Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://localhost/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>go-sql-deiver 源码解析</title>
      <link>http://localhost/go-sql-driver-source-code/</link>
      <pubDate>Sun, 15 Oct 2017 20:31:55 +0800</pubDate>
      
      <guid>http://localhost/go-sql-driver-source-code/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;最近正在给 &lt;code&gt;mysql&lt;/code&gt; 封装一个库，顺带研究一下 &lt;code&gt;go-mysql-driver&lt;/code&gt; 这个库的源码实现。&lt;/p&gt;

&lt;h2 id=&#34;buffer-go&#34;&gt;Buffer.go&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;buffer&lt;/code&gt; 是一个用于给 &lt;strong&gt;数据库连接&lt;/strong&gt; (&lt;code&gt;net.Conn&lt;/code&gt;) 进行缓冲的一个数据结构，其结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type buffer struct {
    buf 	[]byte     // 缓冲池中的数据
  	nc  	net.Conn   // 负责缓冲的数据库连接对象
  	idx 	int		   // 已读数据索引
    length 	int        // 缓冲池中未读数据的长度
   	timeout time.Duration // 数据库连接的超时设置
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，因为  &lt;strong&gt;数据库连接&lt;/strong&gt; (&lt;code&gt;net.Conn&lt;/code&gt;)  在通信的时候是 &lt;strong&gt;同步&lt;/strong&gt; 的。而为了让其能够 &lt;strong&gt;同时 读/写&lt;/strong&gt; ，所以实现了 &lt;code&gt;buffer&lt;/code&gt; 这个数据结构，通过该 &lt;code&gt;buffer&lt;/code&gt; 进行数据缓冲还能实现 &lt;strong&gt;零拷贝&lt;/strong&gt; ( &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%A4%8D%E5%88%B6&#34;&gt;zero-copy-ish&lt;/a&gt; ) 。&lt;/p&gt;

&lt;p&gt;其函数分别有：&lt;/p&gt;

&lt;h4 id=&#34;newbuffer-nc-net-conn-buffer&#34;&gt;&lt;code&gt;newBuffer(nc net.Conn) buffer&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;创建并返回一个 &lt;code&gt;buffer&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;buffer-readnext-need-int-byte-error&#34;&gt;&lt;code&gt;(*buffer) readNext(need int) ([]byte, error)&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;读取并返回未读数据的 &lt;strong&gt;need&lt;/strong&gt; 位，如果 &lt;strong&gt;need&lt;/strong&gt; 大于 &lt;code&gt;buffer&lt;/code&gt; 的 &lt;code&gt;length&lt;/code&gt; ，就会调用 &lt;code&gt;fill(need int) error&lt;/code&gt; 对 &lt;code&gt;buffer&lt;/code&gt;进行 &lt;strong&gt;扩容&lt;/strong&gt; 。&lt;/p&gt;

&lt;h4 id=&#34;buffer-fill-need-int-error&#34;&gt;(*buffer) fill(need int) error`&lt;/h4&gt;

&lt;p&gt;对 &lt;code&gt;buffer&lt;/code&gt; 进行 &lt;code&gt;(need/defaultBufSize)&lt;/code&gt; 的倍数扩容，并在 &lt;code&gt;timeout&lt;/code&gt; 时间结束前从 &lt;code&gt;buffer.nc&lt;/code&gt; 中读取 &lt;strong&gt;need&lt;/strong&gt; 长度的数据。&lt;/p&gt;

&lt;h4 id=&#34;buffer-takebuffer-length-int-byte&#34;&gt;&lt;code&gt;(*buffer) takeBuffer(length int) []byte&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;读取 &lt;code&gt;buffer&lt;/code&gt; 中 &lt;code&gt;length&lt;/code&gt; 长度的数据（只包含已读），如果 &lt;code&gt;buffer.length &amp;gt; 0&lt;/code&gt; ，即还有未读数据，则立即返回 &lt;code&gt;nil&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;如果需要读取的长度大于 &lt;code&gt;buffer&lt;/code&gt; 的容量，则会进行扩容。&lt;/p&gt;

&lt;h4 id=&#34;buffer-takesmallbuffer-length-int-byte&#34;&gt;&lt;code&gt;(*buffer) takeSmallBuffer(length int) []byte&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;读取保证不超过 &lt;code&gt;defaultBufSize&lt;/code&gt; 长度的数据的快捷函数（只包含已读），如果 &lt;code&gt;buffer.length &amp;gt; 0&lt;/code&gt; ，即还有未读数据，则立即返回 &lt;code&gt;nil&lt;/code&gt; 。&lt;/p&gt;

&lt;h4 id=&#34;buffer-takecompletebuffer-byte&#34;&gt;&lt;code&gt;(*buffer) takeCompleteBuffer() []byte&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;读取全部的 &lt;code&gt;buffer&lt;/code&gt; 数据（只包含已读），如果 &lt;code&gt;buffer.length &amp;gt; 0&lt;/code&gt; ，即还有未读数据，则立即返回 &lt;code&gt;nil&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;collations-go&#34;&gt;Collations.go&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;collations&lt;/code&gt; 包含了 &lt;code&gt;MySQL&lt;/code&gt; 所有支持的 &lt;strong&gt;字符集&lt;/strong&gt; 格式，并支持通过 &lt;code&gt;COLLATION_NAME&lt;/code&gt; 返回其字符集 &lt;code&gt;ID&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果需要查询 &lt;code&gt;MySQL&lt;/code&gt; 支持的 &lt;strong&gt;字符集&lt;/strong&gt; 格式，可以使用 &lt;code&gt;SELECT COLLATION_NAME, ID FROM information_schema.COLLATIONS&lt;/code&gt; 语句获取。&lt;/p&gt;

&lt;h2 id=&#34;dsn-go&#34;&gt;Dsn.go&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;DSN&lt;/code&gt; 即 &lt;strong&gt;数据源名称 （Data Source Name）&lt;/strong&gt;  ，是 &lt;strong&gt;驱动程序连接数据库的变量信息&lt;/strong&gt; ，简而言之就是根据你连接的不同数据库使用对应的连接信息。&lt;/p&gt;

&lt;p&gt;通常，数据库的连接配置就是在这里定义的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Config 基本的数据库连接信息
type Config struct {
	User         string            // Username
	Passwd       string            // Password (requires User)
	Net          string            // Network type
	Addr         string            // Network address (requires Net)
	DBName       string            // Database name
	Params       map[string]string // Connection parameters
	Collation    string            // Connection collation
	Loc          *time.Location    // Location for time.Time values
	TLSConfig    string            // TLS configuration name
	tls          *tls.Config       // TLS configuration
	Timeout      time.Duration     // Dial timeout
	ReadTimeout  time.Duration     // I/O read timeout
	WriteTimeout time.Duration     // I/O write timeout

	AllowAllFiles           bool // 允许文件使用 LOAD DATA LOCAL INFILE 导入数据库
	AllowCleartextPasswords bool // 支持明文密码客户端
	AllowOldPasswords       bool // 允许使用不可靠的旧密码
	ClientFoundRows         bool // 返回匹配的行数而不是受影响的行数
	ColumnsWithAlias        bool // 将表名前置在列名
	InterpolateParams       bool // 将占位符插入查询的SQL字符串
	MultiStatements         bool // 允许一条语句多次查询
	ParseTime               bool // 格式化时间值为 time.Time 变量
	Strict                  bool // 将 warnings 返回 errors
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这都是一些常见的配置项，就此略过。&lt;/p&gt;

&lt;p&gt;该文件有两个公共函数支持 &lt;code&gt;Config&lt;/code&gt; 与 &lt;code&gt;DSN&lt;/code&gt; 之间转换。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(*Config)FormatDSN() string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ParseDSN(dsn string) (*Config, error)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;errors-go&#34;&gt;Errors.go&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;errors&lt;/code&gt; 定义了 &lt;code&gt;Logger&lt;/code&gt; 、&lt;code&gt;MySQLError&lt;/code&gt; 、 &lt;code&gt;MySQLWarning&lt;/code&gt; 等数据结构。&lt;/p&gt;

&lt;h4 id=&#34;logger&#34;&gt;Logger&lt;/h4&gt;

&lt;p&gt;复用了 &lt;code&gt;Go&lt;/code&gt; 原生的 &lt;code&gt;log&lt;/code&gt; 包，并将其中的输出重定向至控制台的 &lt;strong&gt;标准错误&lt;/strong&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Logger interface {
  Print(v ...interface{})
}

var errLog = Logger(log.New(os.Stderr, &amp;quot;[mysql]&amp;quot;, log.Ldate|log.Ltime|log.Lshortfile))

func SetLogger(logger Logger) error { // 当然，你也可以使用自定义的错误 Logger
  if logger == nil {
    return errors.New(&amp;quot;logger is nil&amp;quot;)
  }
  errLog =logger
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mysqlerror&#34;&gt;MySQLError&lt;/h4&gt;

&lt;p&gt;而 &lt;code&gt;MySQLError&lt;/code&gt; 则简单定义了 &lt;code&gt;MySQL&lt;/code&gt; 输出的错误的结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MySQLError struct {
	Number  uint16
	Message string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mysqlwarning&#34;&gt;MySQLWarning&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;MySQLWarning&lt;/code&gt; 则有些不一样，它需要从 &lt;code&gt;MySQL&lt;/code&gt; 中进行一次 &lt;strong&gt;查询&lt;/strong&gt; ，以获取所有的警告信息，所以该包也定义了 &lt;code&gt;MySQLWarning&lt;/code&gt; 的 &lt;code&gt;slice&lt;/code&gt; 结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MySQLWarning struct {
    Level string
  	Code string
  	Message string
}

type MySQLWarnings []MySQLWarning

func (mc *mysqlConn) getWarnings() (err error) {
  rows, err := mc.Query(&amp;quot;SHOW WARNINGS&amp;quot;, nil)
  // handle err
  
  // initzation MySQLWarnings
  
  for {
    err = rows.Next(values)
    switch err {
      case nil:
      	warning := MySQLWarning{}
      	
      if raw, ok := values[0].([]byte); ok {
          warning.Level = string(raw)
      }else {
          warning.Level = fmt.Sprintf(&amp;quot;%s&amp;quot;, values[0])
      }
      
      if raw, ok := values[1].([]byte); ok {
        warning.Code = string(raw)
      } else {
        warning.Code = fmt.Sprintf(&amp;quot;%s&amp;quot;, values[1])
      }
      
      if raw, ok := values[2].([]byte); ok {
        warning.Message = string(raw)
      } else {
        warning.Message = fmt.Sprintf(&amp;quot;%s&amp;quot;, values[0])
      }

      warnings = append(warnings, warning)
    }
    
    case io.EOF:
    	return warnings
    
    default:
    	rows.Close() // 值得注意的是，如果该函数没有 case 运行 default ，该 rows 就不会被默认关闭，就会占用连接池中的一个连接，是否应该使用 `defer rows.Close() ` 避免该情况？
    	return
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;infile-go&#34;&gt;Infile.go&lt;/h2&gt;

&lt;p&gt;前面也有提到 &lt;code&gt;MySQL&lt;/code&gt; 在导入大型文件的时候，需要使用 &lt;code&gt;LOAD DATA LOCAL INFILE&lt;/code&gt; 的形式进行导入，而该 &lt;code&gt;infile.go&lt;/code&gt; 就是实现该协议的代码。&lt;/p&gt;

&lt;p&gt;本包在实现的 &lt;code&gt;LOAD DATA&lt;/code&gt; 的时候提供了两种方式进行导入：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最常见的，使用服务器的文件路径，如 &lt;code&gt;/data/students.csv&lt;/code&gt; ，下文命名其为 &lt;strong&gt;文件路径注册器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最通用的，使用实现了 &lt;code&gt;io.Reader&lt;/code&gt; 接口的数据结构，通过返回该数据结构的数据进行导入，如 &lt;code&gt;bytes&lt;/code&gt; &lt;code&gt;os.file&lt;/code&gt; 等，下文命名其为 &lt;strong&gt;Reader 接口注册器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实现该功能的时候，&lt;strong&gt;注册器&lt;/strong&gt; 的实现是用名字作为 Key 的 &lt;code&gt;Map&lt;/code&gt; ，为了避免 &lt;code&gt;Map&lt;/code&gt; 的 &lt;strong&gt;读写竞态&lt;/strong&gt; ，需要对其配置一个读写锁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
	fileRegister	  	map[string]bool  	// 文件路径注册器
  	fileRegisterLock  	sync.RWMutex	   	// 文件路径注册器读写锁
	readerRegister	  	map[string]func() io.Reader // Reader 接口注册器
  	readerRegisterLock 	sync.RWMutex				// Reader 接口注册器读写锁	
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了对两个注册器的 &lt;strong&gt;注册&lt;/strong&gt; 以及 &lt;strong&gt;注销&lt;/strong&gt; 函数，还有一个需要分析的一个函数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(mc *mysqlConn) handleInFileRequest(name string) (err error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过传入 &lt;strong&gt;文件路径&lt;/strong&gt; 或者 &lt;strong&gt;Reader 名称&lt;/strong&gt; 就可以将数据发往 &lt;code&gt;MySQL&lt;/code&gt; 了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (mc *mysqlConn) handleInFileRequest(name string) (err error) {
    packSize := 16 * 1024 // 16KB is small enough for disk readahead and large enough for TCP
    if mc.maxWriteSize &amp;lt; packSize { // 设置发往 MySQL 的数据块大小
        packSize = mc.maxWriteSize
  	}
  
  	// 获取 文件 或 Reader 的数据，并将其赋值到 rdr 中
  	// var rdr io.Reader
  
  	// send context packets
  	if err != nil {
      	data := make([]byte, 4+packetSize) // 需要留 4 个 byte 给协议使用
      	var n int
	    for err == nil {
          	n, err = rdr.Read(data[4:]) // 将数据存入 data 的 [4:] 中
          	if n &amp;gt; 0 {
				if ioErr := mc.writePacket(data[:4+n]); ioErr != nil { // 将 data 数据发往 MySQL
					return ioErr
				}
			}
      	}
      	if err == io.EOF { // rdr 中的数据读完了
			err = nil
		}
  	}
  
  	// send empty packet (termination)
	if data == nil {
		data = make([]byte, 4)
	}
	if ioErr := mc.writePacket(data[:4]); ioErr != nil { // 告诉 MySQL 文件发送完毕
		return ioErr
	}

	// read OK packet
	if err == nil { // 一切正常结束
		return mc.readResultOK()
	}

	mc.readPacket() // 如果中途出错，将错误信息读取到 mysqlConn 中，并返回该错误
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到此，&lt;code&gt;infile.go&lt;/code&gt; 的实现已经整理完毕了，可以看到， 作者 在实现这个功能的时候还是做了一些优化的，比如 &lt;code&gt;map Lazy init&lt;/code&gt; ，&lt;code&gt;send packet size limited&lt;/code&gt; 等。而我们通过分析规范的源码包，能够提升自己的编码水平。&lt;/p&gt;

&lt;h2 id=&#34;packets-go&#34;&gt;Packets.go&lt;/h2&gt;

&lt;p&gt;接下来就要深入到 &lt;code&gt;MySQL&lt;/code&gt; 的通信协议中了，官方的 &lt;a href=&#34;https://dev.mysql.com/doc/internals/en/client-server-protocol.html&#34;&gt;通信协议文档&lt;/a&gt; 非常齐全，我在这里只将一些基础的，我后面分析源码会用到的协议分析下，如果有兴趣，可以到官方文档处进行查阅。&lt;/p&gt;

&lt;h3 id=&#34;protocol-basics&#34;&gt;Protocol Basics&lt;/h3&gt;

&lt;h4 id=&#34;基础数据类型&#34;&gt;基础数据类型&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt; 通信的基本数据类型有两种， &lt;code&gt;Integer&lt;/code&gt; 、 &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Integer : 分别有 &lt;strong&gt;1&lt;/strong&gt;， &lt;strong&gt;2&lt;/strong&gt;， &lt;strong&gt;3&lt;/strong&gt;， &lt;strong&gt;4&lt;/strong&gt;， &lt;strong&gt;8&lt;/strong&gt; 个字节长度的类型，使用小端传输。&lt;/li&gt;
&lt;li&gt;String : 分别有 &lt;strong&gt;固定长度字符串（协议规定）&lt;/strong&gt;，&lt;strong&gt;NULL结尾字符串（长度不固定）&lt;/strong&gt;，&lt;strong&gt;长度编码字符串（长度不固定）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;报文协议&#34;&gt;报文协议&lt;/h4&gt;

&lt;p&gt;报文分为 &lt;strong&gt;消息头&lt;/strong&gt; 以及 &lt;strong&gt;消息体&lt;/strong&gt;，而 &lt;strong&gt;消息头&lt;/strong&gt; 由 3 字节的 &lt;strong&gt;消息长度&lt;/strong&gt; 以及 1 字节的 &lt;strong&gt;序号&lt;/strong&gt;  &lt;code&gt;sequence&lt;/code&gt; （新客户端由 &lt;code&gt;0&lt;/code&gt; 开始）组成，&lt;strong&gt;消息体&lt;/strong&gt; 则由 &lt;strong&gt;消息长度&lt;/strong&gt; 的字节组成。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3 字节的 &lt;strong&gt;消息长度&lt;/strong&gt; 最大值为 &lt;code&gt;0xFFFFFF&lt;/code&gt; ，即为 &lt;code&gt;16 MB - 1 byte&lt;/code&gt; ，这就意味着，如果整个消息（包括消息头）的长度大于 &lt;code&gt;16MB - 1byte - 4byte&lt;/code&gt; 大小时，消息就会被分包。&lt;/li&gt;
&lt;li&gt;1 字节的 &lt;strong&gt;序号&lt;/strong&gt; 在每次新的客户端发起请求时，以 &lt;code&gt;0&lt;/code&gt; 开始，依次递增 1 ，如果消息需要分包， &lt;strong&gt;序号&lt;/strong&gt; 会随着分包的数量递增。而在一次应答中， 客户端会校验服务器 &lt;strong&gt;返回序号&lt;/strong&gt; 是否与 &lt;strong&gt;发送序号&lt;/strong&gt; 一致，如果不一致，则返回错误异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;协议类型&#34;&gt;协议类型&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;handshake&lt;/code&gt; : 发起连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auth&lt;/code&gt; : 登录权限校验&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ok | error&lt;/code&gt; : 返回结果状态 &lt;code&gt;*&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ok&lt;/code&gt; : 首字节为 0 （&lt;code&gt;0x00&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;error&lt;/code&gt; : 首字节为 255 （&lt;code&gt;0xff&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resultset&lt;/code&gt; : 结果集

&lt;ul&gt;
&lt;li&gt;header&lt;/li&gt;
&lt;li&gt;field&lt;/li&gt;
&lt;li&gt;eof&lt;/li&gt;
&lt;li&gt;row&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;command package&lt;/code&gt; : 命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在整个 &lt;code&gt;MySQL&lt;/code&gt; 发起交互的过程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xsxev.com1.z0.glb.clouddn.com/mysql%20%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E5%9B%BE.png&#34; alt=&#34;mysql connect&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在了解这些 &lt;code&gt;MySQL&lt;/code&gt; 基础协议知识后，我们再来看 &lt;code&gt;packages.go&lt;/code&gt; 的源码就轻松多了。&lt;/p&gt;

&lt;h4 id=&#34;源码&#34;&gt;源码&lt;/h4&gt;

&lt;p&gt;先来看看 &lt;code&gt;readPacket&lt;/code&gt; ，结合上面的知识点应该非常好理解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (mc *mysqlConn) readPacket() ([]byte, error) {
    var payload []byte
  	for { // for 循环是为了读取有可能分片的数据
     	// Read package header
      	data, err := mc.buf.readNext(4) // 从 buffer 缓冲器中读取 4 字节的 header
      	if err != nil { // 如果读取发生异常，则关闭连接，并返回一个错误连接的异常
          	errLog.Print(err)
          	mc.Close()
          	return nil, driver.ErrBadConn 
      	}
      
      	// Packet Length [24 bit]
      	pktLen := int(uint32(data[0]) | uint32(data[1])&amp;lt;&amp;lt;8 | uint32(data[2])&amp;lt;&amp;lt;16) // 读取 3 字节的消息长度
      
      	if pktLen &amp;lt; 1 {
          	// 如上所示，关闭连接，并返回一个错误连接的异常
      	}
      
      	// Check Packet Sync [8 bit]
      	if data[3] != mc.sequence { // 判断服务端返回的序号是否与客户端一致
          	if data[3] &amp;gt; mc.sequence {
             	return nil, ErrPktSyncMul // 如果服务端返回序号大于客户端的序号，则有可能是在一次请求中做了多次操作
          	}
          	return nil, ErrPktSync // 返回序号不一致错误
      	}
      	mc.sequence++ // 本次序号匹配相符，为了匹配下一次请求，先将序号自增1
      
      	data, err := mc.buf.readNext(pktLen) // 读取 消息长度 的数据
      	if err != nil {
          	// 如上所示，关闭连接，并返回一个错误连接的异常
      	}
      
      	isLastPacket := (pktLen &amp;lt; maxPacketSize) // 如果是最后一个数据包，必然小于 maxPacketSize (16MB - 1byte)
      	
      	// Zero allocations for non-splitting packets
		if isLastPacket &amp;amp;&amp;amp; payload == nil { // 无分包情况，立即返回
			return data, nil
		}

		payload = append(payload, data...)

		if isLastPacket { // 如果是最后一个包，读取完毕后返回
			return payload, nil
		}
      
      	// 还有未读数据，开始下一次循环
  	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来看下结合 &lt;strong&gt;握手报文协议&lt;/strong&gt; 来看下客户端向服务端发起请求的 &lt;code&gt;readInitPacket&lt;/code&gt; ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xsxev.com1.z0.glb.clouddn.com/mysql_protocol_handshake.png&#34; alt=&#34;mysql handshack protocol&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (mc *mysqlConn) readInitPacket() ([]byte, error) {
  	data, err := mc.readPacket() // 调用上面的函数读取服务端返回的数据
  	if err != nil {
      	return nil, err
  	}
  
  	if data[0] == iERR { // iERR = 0xff  消息体的第一个字节返回 0xff ，则意味着 error package
      	return nil, mc.handleErrorPacket(data)
  	}
  
  	// protocol version [1 byte]
  	if data[0] &amp;lt; minProtocolVersion { // 判断是否是兼容的协议版本
      	return nil, fmt.Errorf(
			&amp;quot;unsupported protocol version %d. Version %d or higher is required&amp;quot;,
			data[0],
			minProtocolVersion,
		)
  	}
  
  	// server version [null terminated string]
	// connection id [4 bytes]
  	pos := 1 + bytes.IndexByte(data[1:], 0x00) + 1 + 4 // 读取 NULL （0x00）为结尾的字符串，跳过服务器线程 ID
  
  	// first part of the password cipher [8 bytes]
  	cipher := data[pos : pos+8] // 获取挑战随机数
  
  	// (filler) always 0x00 [1 byte]
	pos += 8 + 1
  
  	// capability flags (lower 2 bytes) [2 bytes]
	mc.flags = clientFlag(binary.LittleEndian.Uint16(data[pos : pos+2])) // 获取服务器权能标识
	if mc.flags&amp;amp;clientProtocol41 == 0 { // 说明 MySQL 服务器不支持高于 41 版本的协议
		return nil, ErrOldProtocol
	}
	if mc.flags&amp;amp;clientSSL == 0 &amp;amp;&amp;amp; mc.cfg.tls != nil { // 说明 MySQL 服务器需要 SSL 加密，但是客户端没有配置 SSL
		return nil, ErrNoTLS
	}
	pos += 2 // 指针向后两位
  
  	if len(data) &amp;gt; pos {
      	// 指针跳过标志位
		pos += 1 + 2 + 2 + 1 + 10

		// second part of the password cipher [mininum 13 bytes],
		// where len=MAX(13, length of auth-plugin-data - 8)
		//
		// The web documentation is ambiguous about the length. However,
		// according to mysql-5.7/sql/auth/sql_authentication.cc line 538,
		// the 13th byte is &amp;quot;\0 byte, terminating the second part of
		// a scramble&amp;quot;. So the second part of the password cipher is
		// a NULL terminated string that&#39;s at least 13 bytes with the
		// last byte being NULL.
		//
		// The official Python library uses the fixed length 12
		// which seems to work but technically could have a hidden bug.
		cipher = append(cipher, data[pos:pos+12]...)

		// TODO: Verify string termination
		// EOF if version (&amp;gt;= 5.5.7 and &amp;lt; 5.5.10) or (&amp;gt;= 5.6.0 and &amp;lt; 5.6.2)
		// \NUL otherwise
		//
		//if data[len(data)-1] == 0 {
		//	return
		//}
		//return ErrMalformPkt

		// make a memory safe copy of the cipher slice
		var b [20]byte
		copy(b[:], cipher)
		return b[:], nil
	}

	// make a memory safe copy of the cipher slice
	var b [8]byte // 返回 8 字节的挑战随机数
	copy(b[:], cipher)
	return b[:], nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了上面解析的两个函数， &lt;code&gt;packages.go&lt;/code&gt; 还有 &lt;code&gt;initialisation process&lt;/code&gt; / &lt;code&gt;result packages&lt;/code&gt; / &lt;code&gt;prepared statements&lt;/code&gt; 等协议的 &lt;strong&gt;写入/读取&lt;/strong&gt; ，有兴趣的读者可以结合上面的知识点自行阅读。&lt;/p&gt;

&lt;h2 id=&#34;driver-go&#34;&gt;Driver.go&lt;/h2&gt;

&lt;p&gt;接下来就要分析一些比较重要的代码了，比如接下来要讲的 &lt;code&gt;driver.go&lt;/code&gt; ，它主要负责与 &lt;code&gt;MySQL&lt;/code&gt; 数据库进行各种协议的连接，并返回该连接。可以说它才是最基础、最核心的功能。&lt;/p&gt;

&lt;p&gt;不过首先我们需要看下 &lt;code&gt;database/sql&lt;/code&gt; 包中的 &lt;code&gt;Driver&lt;/code&gt; 接口需要如何实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// database/sql/driver/driver.go

// 数据库驱动
type Driver interface {
  Open(name string) (Conn, error)
}

// ...

// 非并发安全数据库连接
type Conn interface {
  // 返回一个绑定到 sql 的准备语句
  Prepare(query string) (Stmt, error)
  
  // 关闭该连接，并标记为不再使用，停止所有准备语句和事务
  // 因为 database/sql 包维护了一个空闲的连接池，并且在空闲连接过多的时候会自动调用 Close ，所以驱动程序包不需要显式调用该函数
  Close() error
  
  // 开始并返回一个新的事务，而新的事务与旧的连接没有任何关联
  Begin() (Tx, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据 &lt;code&gt;database/sql&lt;/code&gt; 提供的 &lt;code&gt;Driver&lt;/code&gt; 接口， &lt;code&gt;go-sql-driver/mysql&lt;/code&gt; 实现了自己的 &lt;strong&gt;数据库驱动&lt;/strong&gt; 结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MySQLDriver struct{}

func (d MySQLDriver) Open(dsn string) (driver.Conn, error) {
  mc := &amp;amp;mysqlConn {
      // set max value
  }
  mc.cfg = ParseDSN(dsn) // 通过解析 DSN 设置 MySQL 连接的配置

  // set parseTime and strict
  // ...
  
  // connect to server
  if dial, ok := dials[mc.cfg.Net]; ok { // 根据 地址 以及 协议类型，尝试连接上服务器
    mc.netConn, err = dial(mc.cfg.Addr)
  } else { // 连接服务器失败，尝试重连
    nd := net.Dialer{Timeout: mc.cfg.Timeout}
    mc.netConn, err := nd.Dial(mc.cfg.Net, mc.cfg.Addr)
  }
  if err !=  nil { // 重试失败，返回异常
      return nil, err
  }
  
  // Enable TCP Keepalives on TCP connections
  if tc, ok := mc.netConn.(*net.Conn); ok { // tcp 连接类型转换
    if err := tc.SetKeepAlive(true); err != nil {
      // Don&#39;t send COM_QUIT before handshake.
      mc.netConn.Close() // 如果设置长连接失败，返回异常之前一定要记得将连接断开
      mc.netConn = nil
      return nil, err
    }
  }
  
  mc.buff = newBuff(mc.netConn) // 生成一个带缓冲的 buffer，如上面 buffer.go 中所说
  
  // set I/O timeout
  // ...
  
  // Reading Handshake Initialization Packet
  cipher, err := mc.readInitPacket() // 发起数据库首次握手
  if err != nil {
    mc.cleanup() // 将当前 mysqlConn 对象销毁，后面我们会说这个函数
    return nil, err
  }
  
  // Send Client Authentication Packet
  if err = mc.writeAuthPacket(cipher); err != nil { // 向数据库发送登录信息校验
    mc.cleanup()
    return nil, err
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;connection-go&#34;&gt;connection.go&lt;/h2&gt;

&lt;p&gt;终于要讲到这个包的核心数据结构 &lt;code&gt;mysqlConn&lt;/code&gt; 了，可以说，驱动的所有功能几乎都围绕着这个数据结构，我们先来看看它的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type mysqlConn struct {
    buf              buffer 	// buffer 缓冲器
	netConn          net.Conn	// 网络连接
	affectedRows     uint64		// sql 执行成功影响行数
	insertId         uint64		// sql 添加成功最新的主键 ID
	cfg              *Config	// dsn 中的 基础配置
  	maxPacketAllowed int		// 允许的最大报文的字节长度，最大不能超过 (16MB - 1byte)
	maxWriteSize     int		// 允许最大的写入字节长度，最大不能超过 (16MB - 1byte)
	writeTimeout     time.Duration 	// 执行 sql 的 超时时间
	flags            clientFlag		// 客户端状态标识
	status           statusFlag		// 服务端状态标识
	sequence         uint8			// 序号
	parseTime        bool			// 是否格式化时间
	strict           bool			// 是否使用严格模式
}

// driver.go
// 而创建一个 mysqlConn 连接需要通过 driver.go 中的 Open 函数，也说明 mysqlConn 实现了 driver.Conn 接口
func (d MySQLDriver) Open(dsn string) (driver.Conn, error) {
  mc := &amp;amp;mysqlConn{
      // ...
  }
  
  // ...
  
  return mc, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个新的客户端连接上服务器的时候 （三次握手结束，客户端进入 &lt;code&gt;established&lt;/code&gt; 状态），需要先对 &lt;code&gt;MySQL&lt;/code&gt; 服务器进行 &lt;strong&gt;会话的用户/系统环境变量&lt;/strong&gt; 的设置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Handles parameters set in DSN after the connection is established
func (mc *mysqlConn) handleParams() (err error) {
  	for param, val := range mc.cfg.Params { // Params: map[string]string
      	switch param {
        // Charset
        case &amp;quot;charset&amp;quot;: // 如果是字符集，则调用 SET NAMES 命令
          	charsets := strings.Split(val, &amp;quot;,&amp;quot;)
			for i := range charsets {
				// ignore errors here - a charset may not exist
				err = mc.exec(&amp;quot;SET NAMES &amp;quot; + charsets[i])
				if err == nil {
					break
				}
			}
			if err != nil {
				return
			}

		// System Vars
		default: // 执行系统环境变量设置
			err = mc.exec(&amp;quot;SET &amp;quot; + param + &amp;quot;=&amp;quot; + val + &amp;quot;&amp;quot;)
			if err != nil {
				return
			}
      	}
  	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;conntion.go&lt;/code&gt;  还负责 &lt;strong&gt;事务&lt;/strong&gt; 、&lt;strong&gt;预处理语句&lt;/strong&gt; 、&lt;strong&gt;执行/查询&lt;/strong&gt; 的管理，但是基本都是往 &lt;code&gt;mysqlConn&lt;/code&gt; 中发送  &lt;code&gt;command package&lt;/code&gt; ，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Begin 开启事务
func (mc *mysqlConn) Begin() (driver.Tx, error) {
	if mc.netConn == nil {
		errLog.Print(ErrInvalidConn)
		return nil, driver.ErrBadConn
	}
	err := mc.exec(&amp;quot;START TRANSACTION&amp;quot;)
	if err == nil {
		return &amp;amp;mysqlTx{mc}, err // 返回成功开启的事务，重用之前的连接
	}

	return nil, err
}

// Internal function to execute commands
func (mc *mysqlConn) exec(query string) error {
    // Send command
  	err := mc.writeCommandPacketStr(comQurey, query)
  	if err != nil {
		return err
	}
  
  	// Read Result
  	resLen, err := mc.readResultSetHeaderPacket() // 根据 data[0] 的值判断是否出错，如果没有错误，则返回消息体的长度
  	if err == nil &amp;amp;&amp;amp; resLen &amp;gt; 0 { // 存在有效消息体
		if err = mc.readUntilEOF(); err != nil { // 读取 columns
			return err
		}

		err = mc.readUntilEOF() // 读取 rows
	}

	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我想 &lt;code&gt;conntion.go&lt;/code&gt; 中最重要的一个函数应该是 &lt;code&gt;cleanup&lt;/code&gt; ，它负责将 &lt;strong&gt;连接关闭&lt;/strong&gt; 、 &lt;strong&gt;重置环境变量&lt;/strong&gt; 等功能，但是该函数不能随意调用，它只有在 &lt;strong&gt;登录权限校验异常&lt;/strong&gt; 时候才应该被调用，否则服务器在不知道客户端 &lt;strong&gt;被强行关闭&lt;/strong&gt; 的情况下，依然会向该客户端发送消息，导致严重异常：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Closes the network connection and unsets internal variables. Do not call this
// function after successfully authentication, call Close instead. This function
// is called before auth or on auth failure because MySQL will have already
// closed the network connection.
func (mc *mysqlConn) cleanup() {
    // Makes cleanup idempotent 保证函数的幂等性
  	if mc.netConn != nil {
      	if err := mc.netConn.Close(); err != nil { // Close 会尝试发送 comQuit command 到服务器
          	errLog.Print(err)
      	}
      	mc.netConn = nil // 不管 Close 是否成功，必须将 netConn 清空
  	}
  	mc.cfg = nil
	mc.buf.nc = nil // 缓冲器中的 netConn 也要关闭
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;result-go&#34;&gt;Result.go&lt;/h2&gt;

&lt;p&gt;每当 &lt;code&gt;MySQL&lt;/code&gt; 返回一个 &lt;code&gt;OK&lt;/code&gt; 的 &lt;strong&gt;状态报文&lt;/strong&gt; ，该报文协议会携带上本次执行的结果 &lt;code&gt;affectedRows&lt;/code&gt; 以及 &lt;code&gt;insertId&lt;/code&gt; ，而 &lt;code&gt;result.go&lt;/code&gt; 就包含着一个数据结构，用于存储本次的执行结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type mysqlResult struct {
    affectedRows int64
  	insertId 	 int64
}

// 两个 getter
func (res *mysqlResult) LastInsertId() (int64, error) {
	return res.insertId, nil
}

func (res *mysqlResult) RowsAffected() (int64, error) {
	return res.affectedRows, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们看下在 &lt;code&gt;conntion.go&lt;/code&gt; 中是怎么生成 &lt;code&gt;mysqlResult&lt;/code&gt; 对象的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// connect.go
func (mc *mysqlConn) Exec(query string, args []driver.Value) (driver.Result, error) {
  
  	// ...
  
  	err := exec(query)
  	if err == nil {
		return &amp;amp;mysqlResult{ // 返回执行的结果
			affectedRows: int64(mc.affectedRows),
			insertId:     int64(mc.insertId),
		}, err
	}
	return nil, err
}

// exec 函数的解析可以返回上面 package.go 中浏览

// package.go
func (mc *mysqlConn) readResultSetHeaderPacket() (int, error) {
	data, err := mc.readPacket()
	if err == nil {
		switch data[0] {

		case iOK:
			return 0, mc.handleOkPacket(data) // 处理 OK 状态报文

		// ...
}

func (mc *mysqlConn) handleOkPacket(data []byte) error {
	var n, m int

	// 0x00 [1 byte]

	// Affected rows [Length Coded Binary]
	mc.affectedRows, _, n = readLengthEncodedInteger(data[1:])

	// Insert id [Length Coded Binary]
	mc.insertId, _, m = readLengthEncodedInteger(data[1+n:])

	// ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;row-go&#34;&gt;Row.go&lt;/h2&gt;

&lt;p&gt;当 &lt;code&gt;MySQL&lt;/code&gt; 执行 &lt;strong&gt;插入、更新、删除&lt;/strong&gt; 等操作后，都会返回 &lt;code&gt;Result&lt;/code&gt; ，但是 &lt;strong&gt;查询&lt;/strong&gt; 返回的是 &lt;code&gt;Rows&lt;/code&gt; ，我们先来看看 &lt;code&gt;go-mysql-driver&lt;/code&gt; 驱动所实现的 &lt;strong&gt;接口&lt;/strong&gt;  &lt;code&gt;Rows&lt;/code&gt; 的接口描述：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// database/sql/driver/driver.go
// Rows 是执行查询返回的结果的 游标
type Rows interface {
    // Columns 返回列的名称，从 slice 的长度可以判断列的长度
  	// 如果一个列的名称未知，则为该列返回一个空字符串
  	Columns() []string
  
  	// Close 关闭游标
  	Close() error
  
  	// Next 将下一行数据填充到 desc 切片中
	// 如果读取的是最后一行数据，应该返回一个 io.EOF 错误
  	Next(desc []Value) error
}

type Value interface{} // Value is a value that drivers must be able to handle.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么我要说这是 &lt;code&gt;go-mysql-driver&lt;/code&gt; 驱动所实现的 &lt;strong&gt;接口&lt;/strong&gt; &lt;code&gt;Rows&lt;/code&gt; 呢？眼尖的同学应该已经看到了， &lt;code&gt;Next&lt;/code&gt; 函数好像和我们平常见到的不一样啊！！&lt;/p&gt;

&lt;p&gt;是的，因为我们平常使用的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rows.Next()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rows.Scan(dest ...interface{}) error&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等函数的对象 &lt;code&gt;rows&lt;/code&gt; 并不是上面的 &lt;strong&gt;接口描述&lt;/strong&gt; &lt;code&gt;Rows&lt;/code&gt; ，而是另一个封装的 &lt;strong&gt;同名数据结构&lt;/strong&gt; &lt;code&gt;Rows&lt;/code&gt; ，它就在 &lt;code&gt;database/sql&lt;/code&gt; 包中 ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// database/sql.go
type Rows struct {
    dc          *driverConn 
	releaseConn func(error)
	rowsi       driver.Rows // 接口描述的 Rows 藏在这！！！
	
	// 忽略其他字段，因为我们不分析这个包...
  
  	// lastcols is only used in Scan, Next, and NextResultSet which are expected
	// not not be called concurrently.
	lastcols []driver.Value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们跳过 &lt;code&gt;database/sql&lt;/code&gt;  包中的 &lt;code&gt;Rows&lt;/code&gt; 实现，其无非是提供了更多功能的一个结果集而已，让我们回到真正与数据库进行交互的 &lt;code&gt;Rows&lt;/code&gt; 中进行源码分析。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;go-sql-driver&lt;/code&gt; 实现的 &lt;code&gt;mysqlRows&lt;/code&gt; 数据结构只实现了 &lt;code&gt;Columns()&lt;/code&gt; 和 &lt;code&gt;Close()&lt;/code&gt; 两个行数，剩下的 &lt;code&gt;Next(desc []driver.Value)&lt;/code&gt; 实现则交给了 &lt;code&gt;MySQL&lt;/code&gt; 的两种结果集协议：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// rows.go

type mysqlField struct {
	tableName string
	name      string
	flags     fieldFlag
	fieldType byte
	decimals  byte
}

type mysqlRows struct {
	mc      *mysqlConn
	columns []mysqlField
}

type binaryRows struct { // 二进制结果集协议
	mysqlRows // 对于 Go 的 组合特性 应该不会陌生吧？
}

type textRows struct { // 文本结果集协议
	mysqlRows
}

func (rows *mysqlRows) Columns() []string {
  	columns := make([]string, len(rows.columns))
  	
  	// 将列名赋值到 columns ，如果有设置别名则赋值别名...
  
  	return columns
}

func (rows *mysqlRows) Close() error {
    // 将连接里面的未读数据读完，然后将连接置空
}

// 接下来的 Next 函数实现就交由 binaryRows 和 textRows 了
func (rows *binaryRows) Next(desc []driver.Value) error {
    if mc := rows.mc; mc != nil {
		if mc.netConn == nil {
			return ErrInvalidConn
		}

		return rows.readRow(dest) // 读二进制协议结果集
	}
	return io.EOF
}

func (rows *testRows) Next(desc []driver.Value) error {
    if mc := rows.mc; mc != nil {
		if mc.netConn == nil {
			return ErrInvalidConn
		}

		return rows.readRow(dest) // 读取文本协议
	}
	return io.EOF
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以说，实现了 &lt;code&gt;driver.Rows&lt;/code&gt; 接口的只有 &lt;code&gt;binaryRows&lt;/code&gt; 和 &lt;code&gt;testRows&lt;/code&gt; ，而他们里面的 &lt;code&gt;readRow(desc)&lt;/code&gt; 实现由于都是和协议强相关的代码，就不再解析了。&lt;/p&gt;

&lt;p&gt;我们跟着源码可以看到，使用 &lt;code&gt;textRows&lt;/code&gt; 的场景在 &lt;code&gt;getSystemVar&lt;/code&gt; 以及 &lt;code&gt;Query&lt;/code&gt; 中，而使用 &lt;code&gt;binaryRows&lt;/code&gt; 的场景在 &lt;code&gt;statement&lt;/code&gt; 中，就是我们下一步需要解析的部分。&lt;/p&gt;

&lt;h2 id=&#34;statement-go&#34;&gt;Statement.go&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Prepared Statement&lt;/code&gt; ，即预处理语句，他有什么优势呢，为什么 &lt;code&gt;MySQL&lt;/code&gt; 要加入它？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行性能更高：&lt;code&gt;MySQL&lt;/code&gt; 会对 &lt;code&gt;Prepared Statement&lt;/code&gt; 语句预先进行编译成模板，并将 &lt;strong&gt;占位符&lt;/strong&gt; 替换 &lt;strong&gt;参数&lt;/strong&gt; 的位置，这样如果频繁执行一条参数只有少量替换的语句时候，性能会得到大量提高。可能有同学会有疑问，为什么 &lt;code&gt;MySQL&lt;/code&gt; 语句还需要编译？那么可以来参考下这篇 &lt;a href=&#34;http://www.cnblogs.com/justfortaste/p/3920140.html&#34;&gt;MySQL Prepare 原理&lt;/a&gt; 。&lt;/li&gt;
&lt;li&gt;传输协议更优：&lt;code&gt;Prepare Statement&lt;/code&gt; 在传输时候使用的是 &lt;code&gt;Binary Protocol&lt;/code&gt; ，比使用 &lt;code&gt;Text Protocol&lt;/code&gt; 的查询具有 &lt;strong&gt;传输数据量更小&lt;/strong&gt; 、 &lt;strong&gt;无需转换数据格式&lt;/strong&gt; 等优势，缓解了 &lt;strong&gt;CPU&lt;/strong&gt; 和 &lt;strong&gt;网络&lt;/strong&gt; 的开销。&lt;/li&gt;
&lt;li&gt;安全性更好：由 &lt;a href=&#34;http://www.cnblogs.com/justfortaste/p/3920140.html&#34;&gt;MySQL Prepare 原理&lt;/a&gt; 我们可以知道，&lt;code&gt;Perpare&lt;/code&gt; 编译之后会生成 __语法树 __，在执行的时候才会将参数传进来，这样就避免了平常直接执行 &lt;code&gt;SQL 语句&lt;/code&gt; 会发生的 &lt;code&gt;SQL 注入&lt;/code&gt; 问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了，先来看下 &lt;code&gt;mysqlStmt&lt;/code&gt; 的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type mysqlStmt struct {
    mc 			*mysqlConn
  	id 			uint32
  	paramCount 	int
  	columns		[]mysqlField // cached from the first query (既然SQL已经预编译好了，返回的结果集列名已经是确定的，所以在收到 PREPARE_OK 之后解析数据后会缓存下来)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们发现，它比 &lt;code&gt;mysqlRows&lt;/code&gt; 多了两个成员变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; ：&lt;code&gt;MySQL&lt;/code&gt; 预处理语句之后，会给该语句分配一个 &lt;code&gt;id&lt;/code&gt; 并返回客户端，用于：

&lt;ul&gt;
&lt;li&gt;客户端提交该 &lt;code&gt;id&lt;/code&gt; 给服务器调用对应的预处理语句。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;paramCount&lt;/code&gt; ：参数数量，等于 &lt;strong&gt;占位符&lt;/strong&gt; 的个数，用于：

&lt;ul&gt;
&lt;li&gt;判断传入的参数个数是否与预编译语句中的占位符个数一致。&lt;/li&gt;
&lt;li&gt;判断返回的 &lt;code&gt;PREPARE_OK&lt;/code&gt; 响应报文是否带有 &lt;strong&gt;参数列名&lt;/strong&gt; 数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面来看看如何创建并使用一个 &lt;code&gt;Prepare Statement&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (mc *mysqlConn) Prepare(query string) (driver.Stmt, error) { // 传入需要预编译的 SQL 语句
    // 检查连接是否可用...
  
  	err = mc.writeCommandPacketStr(comStmtPrepare, query) // 将 SQL 发往数据库进行预编译
  	if err != nil {
		return nil, err
	}

	stmt := &amp;amp;mysqlStmt{ // 预编译成功，先创建 stmt 对象
		mc: mc,
	}
  
  	// Read Result
  	columnCount, err := stmt.readPrepareResultPacket() // 从 stmt 的连接读取返回 响应报文
  	if err == nil {
      	if stmt.paramCount &amp;gt; 0 { // 如果预编译的 SQL 的有参数
          	if err = mc.readUntilEOF(); err != nil { // 读取参数列名数据
				return nil, err
			}
      	}
      	
      	if columnCount &amp;gt; 0 { // 返回执行结果的列表个数
			err = mc.readUntilEOF() // 读取执行结果的列名数据
		}
  	}
  
  	return stmt, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为是已经预编译好的语句，所以在执行的时候只需要将参数传进去就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (stmt *mysqlStmt) Exec(args []driver.Value) (driver.Result, error) {
    // 检查连接是否可用...
  
  	err := stmt.writeExecutePacket(args)
	if err != nil {
		return nil, err
	}
  
  	// 读取结果集的行、列数据
}

func(stmt *mysqlStmt) writeExecutePacket(args []driver.Value) error {
  	if len(args) != stmt.paramCount { // 判断传进来的参数和预编译好的SQL参数 个数是否一致
		return fmt.Errorf(
			&amp;quot;argument count mismatch (got: %d; has: %d)&amp;quot;,
			len(args),
			stmt.paramCount,
		)
	}
  
  	// 读取缓冲器中的数据，如果为空，则返回异常...
  
  	// command [1 byte]
	data[4] = comStmtExecute

	// statement_id [4 bytes] 将预编译语句的 id 转换为 4字节的二进制数据
	data[5] = byte(stmt.id)
	data[6] = byte(stmt.id &amp;gt;&amp;gt; 8)
	data[7] = byte(stmt.id &amp;gt;&amp;gt; 16)
	data[8] = byte(stmt.id &amp;gt;&amp;gt; 24)

	// flags (0: CURSOR_TYPE_NO_CURSOR) [1 byte]
	data[9] = 0x00

	// iteration_count (uint32(1)) [4 bytes]
	data[10] = 0x01
	data[11] = 0x00
	data[12] = 0x00
	data[13] = 0x00
  
  	// 将参数按照不同的类型转换为 binary protobuf 并 append 到 data 中...
  
  	return mc.writePacket(data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信看到这里，已经能对看懂源码的 70% 了，剩余的代码都是和协议相关，就留待有兴趣的读者继续研究，这里就不再展开讲了。&lt;/p&gt;

&lt;h2 id=&#34;transaction-go&#34;&gt;Transaction.go&lt;/h2&gt;

&lt;p&gt;事务是 &lt;code&gt;MySQL&lt;/code&gt; 中很重要的一部分，但是驱动的实现却很简单，因为一切的事务控制都已经交由 &lt;code&gt;MySQL&lt;/code&gt; 去执行了，驱动所需要做的，只要发送一个 &lt;code&gt;commit&lt;/code&gt; 或者 &lt;code&gt;rollback&lt;/code&gt; 的 &lt;code&gt;command packet&lt;/code&gt; 即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type mysqlTx struct {
	mc *mysqlConn
}

func (tx *mysqlTx) Commit() (err error) {
	if tx.mc == nil || tx.mc.netConn == nil {
		return ErrInvalidConn
	}
	err = tx.mc.exec(&amp;quot;COMMIT&amp;quot;)
	tx.mc = nil
	return
}

func (tx *mysqlTx) Rollback() (err error) {
	if tx.mc == nil || tx.mc.netConn == nil {
		return ErrInvalidConn
	}
	err = tx.mc.exec(&amp;quot;ROLLBACK&amp;quot;)
	tx.mc = nil
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;最后，其实 &lt;code&gt;buffer&lt;/code&gt; 的实现对我来说印象是最深刻的，因为它是最简单而又是最有效的实现了一个消息缓冲器，它实现的巧妙让我决定把它放到第一节，而其他的几乎都和 &lt;code&gt;MySQL&lt;/code&gt; 的协议相关，看这些源码让我对 &lt;code&gt;MySQL&lt;/code&gt; 有了更多的认识。&lt;/p&gt;

&lt;p&gt;好了，本篇字数比较多，也会有很多不足，希望大家能够给本篇博客多提点意见，让我可以改进的更好。如果还有机会，我会带来其他篇章的源码解析，敬请期待 :)&lt;/p&gt;

&lt;h2 id=&#34;参考链接&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/davygeek/p/5647581.html&#34;&gt;http://www.cnblogs.com/davygeek/p/5647581.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/justfortaste/p/3920140.html&#34;&gt;http://www.cnblogs.com/justfortaste/p/3920140.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#439-prepare_ok-prepared-statement&#34;&gt;http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#439-prepare_ok-prepared-statement&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang Error: bad file descriptor</title>
      <link>http://localhost/golang-bad-file-descriptor/</link>
      <pubDate>Sat, 15 Oct 2016 23:33:50 +0800</pubDate>
      
      <guid>http://localhost/golang-bad-file-descriptor/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;好久没写 Blog 了，正好今天写了一个爬取 &lt;strong&gt;Bing&lt;/strong&gt; 首页高清图片的服务 Application =&amp;gt; &lt;a href=&#34;https://github.com/HackeZ/bingImgCrawer&#34;&gt;bingImgCrawer&lt;/a&gt; 碰到了之前遇到的一个写文件的问题，现在就将其纪录下来吧。&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;p&gt;我的需求是将匹配出来的 &lt;strong&gt;图片URL&lt;/strong&gt; 按照日期纪录到 &lt;code&gt;img_url.txt&lt;/code&gt; 文件中。&lt;/p&gt;

&lt;p&gt;下面是我的问题代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;const (
    LogFile = &amp;quot;./img_url.txt&amp;quot;
)
func logFile(url string) {
    ver file *os.File 
    var err error
    if isExist(LogFile) {
        file, err = os.OpenFile(LogFile, os.O_APPEND, 0666)
    } else {
        log.Println(&amp;quot;log file not exist, creating...&amp;quot;)
		file, err = os.Create(LogFile)
    }
    defer file.Close()
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当文件已经存在的时候，调用 &lt;code&gt;file, err = os.OpenFile(LogFile, O_APPEND, 0666)&lt;/code&gt; 语句打开的 file 变量在使用 &lt;code&gt;file.WriteString(...)&lt;/code&gt; 方法的时候，会出现错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;write ./img_url.txt: bad file descriptor
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solve&#34;&gt;Solve&lt;/h2&gt;

&lt;p&gt;当第一次遇到该错误的时候，我还以为是上一次的线程使用完 &lt;code&gt;img_url.txt&lt;/code&gt; 之后没有释放掉文件句柄，而导致第二次获取该文件句柄的时候出现的 &lt;code&gt;bad file descriptor&lt;/code&gt; 错误。&lt;/p&gt;

&lt;p&gt;于是我将打开该文件的变量作为 &lt;strong&gt;全局变量&lt;/strong&gt; 进行写入操作，问题依然没有得到解决（因为改动太多，代码就不放出来了）&lt;/p&gt;

&lt;p&gt;于是只能借助万能的 stack overflow 了。。。&lt;/p&gt;

&lt;p&gt;解决办法 =&amp;gt; &lt;a href=&#34;http://stackoverflow.com/questions/33851692/golang-bad-file-descriptor&#34;&gt;Golang bad file descriptor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原来是我没有将写文件的 &lt;strong&gt;flag&lt;/strong&gt; 也写进去&amp;hellip;原来 &lt;code&gt;O_APPEND&lt;/code&gt; 只是负责当用户有写入文件这个动作的时候，将文件指针指向文件结尾。&lt;/p&gt;

&lt;p&gt;正确写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;    if isExist(LogFile) {
        file, err = os.OpenFile(LogFile, os.O_WRONLY | os.O_APPEND, 0666)
    } else {
        log.Println(&amp;quot;log file not exist, creating...&amp;quot;)
		file, err = os.Create(LogFile)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后再好奇一件事情， &lt;code&gt;os.O_WRONLY | os.O_APPEND&lt;/code&gt; 的结果是什么呢？&lt;/p&gt;

&lt;p&gt;上代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
    fmt.Println(os.O_APPEND)  // 8
	fmt.Println(os.O_WRONLY)  // 1
	fmt.Println(os.O_RDWR)    // 2
	fmt.Println(os.O_APPEND | os.O_WRONLY) // 9
	fmt.Println(os.O_APPEND | os.O_RDWR)   // 10
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后翻定义，见 &lt;code&gt;/usr/local/go/src/syscall/zerrors_darwin_amd64.go&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ...
    O_APPEND = 0x8
    ...
    O_RDWR = 0x2
    ...
    O_WRONLY = 0x1
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OVER&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/33851692/golang-bad-file-descriptor&#34;&gt;Golang bad file descriptor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/yjp19871013/article/details/8138449&#34;&gt;关于打开文件时O_APPEND标志的作用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CircuitBreaker 设计模式</title>
      <link>http://localhost/circuitbreaker/</link>
      <pubDate>Sun, 25 Sep 2016 23:27:46 +0800</pubDate>
      
      <guid>http://localhost/circuitbreaker/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;今天发现了 &lt;a href=&#34;https://github.com/sony/&#34;&gt;Sony&lt;/a&gt; 竟然在 Github 上开源了他们的一些项目！而他们也是在用 &lt;code&gt;Golang&lt;/code&gt; 在开发后台！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Amazing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;于是不亦乐乎地看起了其中的 Golang 开源项目，而其中一个名为 &lt;a href=&#34;https://github.com/sony/gobreaker&#34;&gt;sony/gobreaker&lt;/a&gt; 的项目引起了我的注意。&lt;/p&gt;

&lt;p&gt;项目简述中描述了这是一个 Golang 版本的 &lt;strong&gt;CircuitBreaker&lt;/strong&gt; 实现！&lt;/p&gt;

&lt;p&gt;那么什么是 &lt;strong&gt;CircuitBreaker（断路器）&lt;/strong&gt; 呢？下面就来一起看看。&lt;/p&gt;

&lt;h2 id=&#34;what-is-circuitbreaker&#34;&gt;What is CircuitBreaker&lt;/h2&gt;

&lt;p&gt;根据传统的解释，断路器是广泛用于 &lt;em&gt;电子工程产业&lt;/em&gt; 的一个重要安全保障！&lt;/p&gt;

&lt;p&gt;当你家里的洗衣机漏电了，电流就会瞬间增大，那么连接家里总线的 &lt;strong&gt;断路器&lt;/strong&gt; 就会剩下，及时切断总电源，防止意外的发生！&lt;/p&gt;

&lt;p&gt;那么在最近的 &lt;code&gt;微服务&lt;/code&gt; 越来越流行的时代，软件架构开始将 &lt;strong&gt;断路器&lt;/strong&gt; 这一概念添加进来了。&lt;/p&gt;

&lt;p&gt;我们知道，当你一旦开始将系统中的一部分拆解为一个独立服务，那么你就已经走进了 &lt;code&gt;微服务&lt;/code&gt; 的时代了。
而在微服务中最重要的是要保证服务运行的稳定性，如果独立服务无法提供高质量或者是不能提供服务，那么这将会导致整个系统的崩溃！&lt;/p&gt;

&lt;p&gt;而 &lt;code&gt;微服务&lt;/code&gt; 会遇到的故障有可能是：
    - 瞬时故障：如慢的网络连接、超时，资源过度使用而暂时不可用；
    - 不容易预见的突发故障：需要更长时间来纠正的故障；&lt;/p&gt;

&lt;p&gt;而解决这些故障常常有两种方法：
    - 重试机制：对于预期的短暂故障问题，通过重试模式是可以解决的；
    - 断路器（CircuitBreaker）模式：将受保护的服务封装在一个可以监控故障的断路器对象中，当故障达到一定门限，断路器将跳闸（trip），所有后继调用将不会发往受保护的服务而由断路器对象之间返回错误。对于需要更长时间解决的故障问题，不断重试就没有太大意义了，可以使用断路器模式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://martinfowler.com/bliki/images/circuitBreaker/sketch.png?_=0.814744712175792&#34; alt=&#34;CircuitBreaker - Sketch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://martinfowler.com/bliki/images/circuitBreaker/state.png?_=0.47541342622693494&#34; alt=&#34;CircuitBreaker - State&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;action-in-gobreaker&#34;&gt;Action in gobreaker&lt;/h2&gt;

&lt;p&gt;简单介绍完 CircuitBreaker 的概念，那么接下来就结合 &lt;a href=&#34;https://github.com/sony/gobreaker&#34;&gt;gobreaker&lt;/a&gt; 的源码实际看看如何设计一个 断触器。&lt;/p&gt;

&lt;p&gt;首先一个值得我们关注的点是 CircuitBreaker State， 它被设计为 &lt;strong&gt;3&lt;/strong&gt; 种状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type State int
const (
    StateClosed State = iota
    StateHalfOpen
    StateOpen
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CircuitBreaker 会根据当前处于不同的 &lt;code&gt;State&lt;/code&gt; ，而判断最多可以通过多少个 &lt;code&gt;Request&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;接下来是 &lt;code&gt;Setting&lt;/code&gt; ，通过 Setting 对象的值，可以新建出一个 CircuitBreaker ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Settings struct {
	Name          string  // CircuitBreaker 的名字
	MaxRequests   uint32  // 最大连接数，根据 State 会自动调节允许通过的 Request 值
	Interval      time.Duration // 当 CircuitBreaker 处于 Close 状态的时候，循环该时间段，清空连接数
	Timeout       time.Duration // 当 CircuitBreaker 处于 Open 状态的时候，如果触发了该超时时间，将它置为 Half-Open
	ReadyToTrip   func(counts Counts) bool // 判断当前失败数，是否应该进入 Close 状态
	OnStateChange func(name string, from State, to State) // 当状态发生变化时候，触发该函数
}

func NewCircuitBreaker(st Settings) *CircuitBreaker {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为这个源码实现其实非常简单，我也就不一一讲诉了，就再将一个比较重要的函数 &lt;code&gt;Execute&lt;/code&gt; 吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (cb *CircuitBreaker) Execute(req func() (interface{}, error)) (interface{}, error) {
	generation, err := cb.beforeRequest()
	if err != nil {
		return nil, err
	}

	defer func() {
		e := recover()
		if e != nil {
			cb.afterRequest(generation, fmt.Errorf(&amp;quot;panic in request&amp;quot;))
			panic(e)
		}
	}()

	result, err := req()
	cb.afterRequest(generation, err)
	return result, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数用于执行需要 CircuitBreaker 触发的函数，详情可以参考这里 =&amp;gt; &lt;a href=&#34;https://github.com/sony/gobreaker/blob/master/example/http_breaker.go&#34;&gt;example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先执行 CircuitBreaker 的 beforeRequest，然后执行传进来的 req 函数，最后执行 afterRequest ，并捕获异常，如果有异常， recover 它，不停止程序，返回错误信息。&lt;/p&gt;

&lt;h2 id=&#34;参考网站&#34;&gt;参考网站&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.sina.com.cn/s/blog_72ef7bea0102vvsn.html&#34;&gt;mryqu - blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/davidwang456/p/3976607.html&#34;&gt;English&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>tcpdump in Action</title>
      <link>http://localhost/tcpdump-in-action/</link>
      <pubDate>Fri, 16 Sep 2016 10:07:54 +0800</pubDate>
      
      <guid>http://localhost/tcpdump-in-action/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;昨天上线了新完成的网站 &lt;a href=&#34;http://123.207.0.81:8563&#34;&gt;Personal-Dictionary&lt;/a&gt; &lt;a href=&#34;https://www.github.com/HackeZ/Personal-Dictionary&#34;&gt;源码在此&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是上线期间却发生网站从 &lt;a href=&#34;http://127.0.0.1:8563&#34;&gt;http://127.0.0.1:8563&lt;/a&gt; 可以访问，但是外网访问却显示 &lt;code&gt;“无法访问此网络”&lt;/code&gt; 的情况，最后通过分析抓包工具 &lt;code&gt;tcpdump&lt;/code&gt; 的结果解决了该问题。&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;p&gt;这是一个 &lt;code&gt;Beego&lt;/code&gt; 应用，按理来说只要编译出二进制文件，然后将静态文件和二进制文件发送到服务器端，然后运行该二进制文件即可。&lt;/p&gt;

&lt;p&gt;编译 Linux OS 下可执行文件的命令为&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o PD main.go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;编译完成之后， 通过 &lt;code&gt;$ scp PD root@123.207.0.81:/home/...&lt;/code&gt; 将文件上传至服务器。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;$ nohup ./PD &amp;amp;&lt;/code&gt; 即可将该应用以后台服务的形式运行在服务器中。&lt;/p&gt;

&lt;p&gt;但是问题出现了，通过外网的 IP 地址访问该 应用的端口地址却提示 &lt;code&gt;“无法访问此网络”&lt;/code&gt; 的情况， 然后我使用 &lt;code&gt;$ curl http://127.0.0.1:8563&lt;/code&gt; 却能直接返回网页内容！&lt;/p&gt;

&lt;h2 id=&#34;slove&#34;&gt;Slove&lt;/h2&gt;

&lt;p&gt;为了解决这个问题，我最先想到的就是该端口是否被外网的中间件屏蔽了呢。有一个最直观的方法可以观察检查该情况，就是使用 &lt;code&gt;tcpdump&lt;/code&gt; 抓包工具！&lt;/p&gt;

&lt;p&gt;在服务器端启动应用之后，使用 &lt;code&gt;$ tcpdump 网卡[eth0, lo] tcp port 8563 host 123.207.0.81&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;去截获访问该应用的端口 TCP 包，然后通过浏览器访问 &lt;a href=&#34;http://123.207.0.81:8563&#34;&gt;http://123.207.0.81:8563&lt;/a&gt; 测试 TCP 包是否能正确到达 服务器的该端口。&lt;/p&gt;

&lt;p&gt;结果 tcpdump 截获到的结果可以简化为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.... [S]
.... [R.]
.... [S]
.... [R.]
.... [S]
.... [R.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显了：
    - &lt;code&gt;S&lt;/code&gt; 代表着 &lt;code&gt;SEND&lt;/code&gt;
    - &lt;code&gt;R&lt;/code&gt; 代表着 &lt;code&gt;RST&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;浏览器试图访问该端口，然后服务器直接就 RST 掉该请求，这样的情况下很可能就是该端口没有被打开！&lt;/p&gt;

&lt;p&gt;关于更多的 RST 情况我推荐一篇 Blog —— &lt;a href=&#34;https://my.oschina.net/costaxu/blog/127394&#34;&gt;costaxu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根据上面的情况，我很快就能定位到问题所在：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// main.go
func main() {
    beego.Run(&amp;quot;127.0.0.1&amp;quot;+beego.AppConfig.String(&amp;quot;httpport&amp;quot;)) // 这里只指定了内网的服务地址...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，只需要将 &lt;code&gt;beego.Run()&lt;/code&gt; 替换掉上面的即可解决。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Action in Protocol Buffers</title>
      <link>http://localhost/protocol-buffers/</link>
      <pubDate>Fri, 09 Sep 2016 09:44:00 +0800</pubDate>
      
      <guid>http://localhost/protocol-buffers/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;如果要介绍 &lt;code&gt;Protocol Buffers&lt;/code&gt; 那么首先要从 RPC 说起，而熟悉分布式的同学应该都知道 RPC 吧，我简单介绍一下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PRC 也就是 Remote Procedure Call Protocol (远程调用协议)，也就是说当有 A, B 两台服务器，A 服务器 中可以通过 RPC 调用 B服务器 中的函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在微服务和分布式变得越来越流行的今天，了解和学会 RPC 这个协议无疑是首要任务。&lt;/p&gt;

&lt;h2 id=&#34;protocol-buffers&#34;&gt;Protocol Buffers&lt;/h2&gt;

&lt;p&gt;那么 RPC 只是一个应用层协议，可以由不同的框架实现，而不同框架所支持的传输数据格式可以有很多：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JSON&lt;/li&gt;
&lt;li&gt;Gob&lt;/li&gt;
&lt;li&gt;MessagePack&lt;/li&gt;
&lt;li&gt;Protocol Buffers &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么可以说 &lt;code&gt;Protocol Buffers&lt;/code&gt; 是这些所被支持的传输数据中比较高效而且通用的一种，其 &lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34;&gt;官网&lt;/a&gt; 就列举出如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;C#&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;的使用指南，而更多的如 &lt;code&gt;Ruby&lt;/code&gt; &lt;code&gt;JavaNano&lt;/code&gt; 等也可以被支持。&lt;/p&gt;

&lt;h2 id=&#34;install-in-go&#34;&gt;Install in Go&lt;/h2&gt;

&lt;p&gt;在 Go 中，我们可以直接使用 &lt;code&gt;protoc-gen-go&lt;/code&gt; 这个工具由 &lt;code&gt;.proto&lt;/code&gt; 模版文件直接生成可用的 &lt;code&gt;.go&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;安装方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先需要下载 &lt;code&gt;Protobuf&lt;/code&gt; 的编译器 &lt;a href=&#34;https://github.com/google/protobuf/releases&#34;&gt;protoc&lt;/a&gt; ，你可以下载一个对应系统版本的二进制版本，然后解压缩之后会在 &lt;code&gt;bin&lt;/code&gt; 文件夹下找到编译好的可执行文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后需要安装 &lt;code&gt;protoc-gen-go&lt;/code&gt; 插件和编解码支持库。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 插件安装
$ go get github.com/golang/protobuf/protoc-gen-go
$ cd $\
GOPATH/src/github.com/golang/protobuf/protoc-gen-go
$ go build &amp;amp;&amp;amp; go install

# 编解码支持库
$ go get github.com/golang/protobuf/proto
$ cd $\
GOPATH/src/github.com/golang/golang/protobuf/proto
$ go build &amp;amp;&amp;amp; go install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后还需要将 &lt;code&gt;$GOPAHTH/bin&lt;/code&gt; &lt;strong&gt;加入环境变量&lt;/strong&gt; ！&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装完成之后，可以在测试文件夹里先新建一个 &lt;code&gt;.proto&lt;/code&gt; 文件，往里面写入：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;syntax=&amp;quot;proto2&amp;quot;;
package xx // 该文件所属包名

enum FOO { X = 17; };

message Test {
    required string label = 1;
    optional int32 type = 2 [default=77];
    repeated int64 reps = 3;
    optional group OptionalGroup = 4 {
    required string RequiredField = 5;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行 &lt;code&gt;protoc -I=&#39;*.proto文件所处的文件夹&#39; --go_out=. *.proto&lt;/code&gt; 即可生成以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Code generated by protoc-gen-go.
// source: example/human.proto
// DO NOT EDIT!

/*
Package example is a generated protocol buffer package.

It is generated from these files:
       	example/human.proto

It has these top-level messages:
       	Test
*/
package example

import proto &amp;quot;github.com/golang/protobuf/proto&amp;quot;
import fmt &amp;quot;fmt&amp;quot;
import math &amp;quot;math&amp;quot;

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FOO int32

const (
       	FOO_X FOO = 17
)

var FOO_name = map[int32]string{
       	17: &amp;quot;X&amp;quot;,
}
var FOO_value = map[string]int32{
       	&amp;quot;X&amp;quot;: 17,
}

func (x FOO) Enum() *FOO {
       	p := new(FOO)
       	*p = x
       	return p
}
func (x FOO) String() string {
       	return proto.EnumName(FOO_name, int32(x))
}
func (x *FOO) UnmarshalJSON(data []byte) error {
       	value, err := proto.UnmarshalJSONEnum(FOO_value, data, &amp;quot;FOO&amp;quot;)
       	if err != nil {
       		return err
       	}
       	*x = FOO(value)
       	return nil
}
func (FOO) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Test struct {
       	Label            *string             `protobuf:&amp;quot;bytes,1,req,name=label&amp;quot; json:&amp;quot;label,omitempty&amp;quot;`
       	Type             *int32              `protobuf:&amp;quot;varint,2,opt,name=type,def=77&amp;quot; json:&amp;quot;type,omitempty&amp;quot;`
       	Reps             []int64             `protobuf:&amp;quot;varint,3,rep,name=reps&amp;quot; json:&amp;quot;reps,omitempty&amp;quot;`
       	Optionalgroup    *Test_OptionalGroup `protobuf:&amp;quot;group,4,opt,name=OptionalGroup,json=optionalgroup&amp;quot; json:&amp;quot;optionalgroup,omitempty&amp;quot;`
       	XXX_unrecognized []byte              `json:&amp;quot;-&amp;quot;`
}

func (m *Test) Reset()                    { *m = Test{} }
func (m *Test) String() string            { return proto.CompactTextString(m) }
func (*Test) ProtoMessage()               {}
func (*Test) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

const Default_Test_Type int32 = 77

func (m *Test) GetLabel() string {
       	if m != nil &amp;amp;&amp;amp; m.Label != nil {
       		return *m.Label
       	}
       	return &amp;quot;&amp;quot;
}

func (m *Test) GetType() int32 {
       	if m != nil &amp;amp;&amp;amp; m.Type != nil {
       		return *m.Type
       	}
       	return Default_Test_Type
}

func (m *Test) GetReps() []int64 {
       	if m != nil {
       		return m.Reps
       	}
       	return nil
}

func (m *Test) GetOptionalgroup() *Test_OptionalGroup {
       	if m != nil {
       		return m.Optionalgroup
       	}
       	return nil
}

type Test_OptionalGroup struct {
       	RequiredField    *string `protobuf:&amp;quot;bytes,5,req,name=RequiredField,json=requiredField&amp;quot; json:&amp;quot;RequiredField,omitempty&amp;quot;`
       	XXX_unrecognized []byte  `json:&amp;quot;-&amp;quot;`
}

func (m *Test_OptionalGroup) Reset()                    { *m = Test_OptionalGroup{} }
func (m *Test_OptionalGroup) String() string            { return proto.CompactTextString(m) }
func (*Test_OptionalGroup) ProtoMessage()               {}
func (*Test_OptionalGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *Test_OptionalGroup) GetRequiredField() string {
       	if m != nil &amp;amp;&amp;amp; m.RequiredField != nil {
       		return *m.RequiredField
       	}
       	return &amp;quot;&amp;quot;
}

func init() {
       	proto.RegisterType((*Test)(nil), &amp;quot;example.Test&amp;quot;)
       	proto.RegisterType((*Test_OptionalGroup)(nil), &amp;quot;example.Test.OptionalGroup&amp;quot;)
       	proto.RegisterEnum(&amp;quot;example.FOO&amp;quot;, FOO_name, FOO_value)
}

func init() { proto.RegisterFile(&amp;quot;example/human.proto&amp;quot;, fileDescriptor0) }

var fileDescriptor0 = []byte{
       	// 200 bytes of a gzipped FileDescriptorProto
       	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0x12, 0x4e, 0xad, 0x48, 0xcc,
       	0x2d, 0xc8, 0x49, 0xd5, 0xcf, 0x28, 0xcd, 0x4d, 0xcc, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17,
       	0x62, 0x87, 0x0a, 0x2a, 0x1d, 0x62, 0xe4, 0x62, 0x09, 0x49, 0x2d, 0x2e, 0x11, 0x12, 0xe1, 0x62,
       	0xcd, 0x49, 0x4c, 0x4a, 0xcd, 0x91, 0x60, 0x54, 0x60, 0xd2, 0xe0, 0x0c, 0x82, 0x70, 0x84, 0xc4,
       	0xb8, 0x58, 0x4a, 0x2a, 0x0b, 0x52, 0x25, 0x98, 0x14, 0x18, 0x35, 0x58, 0xad, 0x98, 0xcc, 0xcd,
       	0x83, 0xc0, 0x7c, 0x21, 0x21, 0x2e, 0x96, 0xa2, 0xd4, 0x82, 0x62, 0x09, 0x66, 0x05, 0x66, 0x0d,
       	0xe6, 0x20, 0x30, 0x5b, 0xc8, 0x91, 0x8b, 0x37, 0xbf, 0xa0, 0x24, 0x33, 0x3f, 0x2f, 0x31, 0x27,
       	0xbd, 0x28, 0xbf, 0xb4, 0x40, 0x82, 0x45, 0x81, 0x51, 0x83, 0xcb, 0x48, 0x5a, 0x0f, 0x6a, 0x97,
       	0x1e, 0xc8, 0x1e, 0x3d, 0x7f, 0xa8, 0x12, 0x77, 0x90, 0x92, 0x20, 0x54, 0x1d, 0x52, 0xa6, 0x5c,
       	0xbc, 0x28, 0xf2, 0x42, 0x2a, 0x5c, 0xbc, 0x41, 0xa9, 0x85, 0xa5, 0x99, 0x45, 0xa9, 0x29, 0x6e,
       	0x99, 0xa9, 0x39, 0x29, 0x12, 0xac, 0x60, 0xd7, 0xf1, 0x16, 0x21, 0x0b, 0x6a, 0xf1, 0x70, 0x31,
       	0xbb, 0xf9, 0xfb, 0x0b, 0xb1, 0x72, 0x31, 0x46, 0x08, 0x08, 0x02, 0x02, 0x00, 0x00, 0xff, 0xff,
       	0x89, 0x47, 0xa8, 0x4e, 0xf1, 0x00, 0x00, 0x00,
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>How to Use Captcha in Beego Correct</title>
      <link>http://localhost/how2use-captcha-in-beego/</link>
      <pubDate>Thu, 01 Sep 2016 18:45:49 +0800</pubDate>
      
      <guid>http://localhost/how2use-captcha-in-beego/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;最近在做 Beego 的 Web 网站开发，主题是 &lt;code&gt;个人词典&lt;/code&gt; ，项目地址 &lt;a href=&#34;https://github.com/HackeZ/Personal-Dictionary&#34;&gt;点我&lt;/a&gt; 。
在关于 Beego 的验证码使用方法上出现了问题，后面通过阅读 Beego 的源码解决了该问题，下面来详细讲诉一下。&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;p&gt;先来看看错误的代码吧&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ...
var cpt *captcha.Captcha

func (c *MainController) Login () {
    // ...
    // Get Verification Code.
    store = cache.NewMemoryCache()
    cpt = captcha.NewWithFilter(&amp;quot;/captcha/&amp;quot;, store)
	cpt.ChallengeNums, _ = beego.AppConfig.Int(&amp;quot;captcha_length&amp;quot;)
	cpt.StdWidth = 100
	cpt.StdHeight = 42

    c.TplName = &amp;quot;login.tpl&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写出现的问题是，开启服务器之后，只有第一次输入的验证码是正确的，一旦刷新页面或者已经登录之后，无论再次怎么进行登录都是 &lt;code&gt;验证码不正确&lt;/code&gt; 的错误。
甚至在很多情况下都会出现验证码图片显示不出来。&lt;/p&gt;

&lt;h2 id=&#34;solve&#34;&gt;Solve&lt;/h2&gt;

&lt;p&gt;其实很容易就可以想到是 Cache 模块而导致的问题，因为 Beego 的 Memory Cache 从源代码中看其实就是一个存放在内存的 &lt;code&gt;Map&lt;/code&gt; ，而且该 &lt;code&gt;Map&lt;/code&gt; 是带生存周期的。所以应该将 &lt;code&gt;Cache&lt;/code&gt; 设置为一个全局变量，那么才能可以让 &lt;code&gt;Captcha&lt;/code&gt; 每次都能到正确的内存地址中的 Map 存取数据。而不是每次访问都新建一次 &lt;code&gt;Cache&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;正确的用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ...
var cpt *captcha.Captcha
var store cache.Cache

func (c *MainController) Login () {
    // ...
    // Get Verification Code.
    cpt = captcha.NewWithFilter(&amp;quot;/captcha/&amp;quot;, store)
	cpt.ChallengeNums, _ = beego.AppConfig.Int(&amp;quot;captcha_length&amp;quot;)
	cpt.StdWidth = 100
	cpt.StdHeight = 42

    c.TplName = &amp;quot;login.tpl&amp;quot;
}

func init() {
    store = cache.NewMemoryCache()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，无论是怎么折腾该验证码， &lt;code&gt;Captcha&lt;/code&gt; 都能到正确的 &lt;code&gt;Map&lt;/code&gt; 中进行操作，一切的问题都解决了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fun in Docker Day-2</title>
      <link>http://localhost/fun-in-docker-2/</link>
      <pubDate>Wed, 31 Aug 2016 19:17:28 +0800</pubDate>
      
      <guid>http://localhost/fun-in-docker-2/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;今天来详细讲一下之前没有讲清楚的 Docker 镜像打包方法。&lt;/p&gt;

&lt;h2 id=&#34;page-command&#34;&gt;Page Command&lt;/h2&gt;

&lt;p&gt;我们都知道，打包 Docker 应用有两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在已经存在的 images 中 commit 修改。&lt;/li&gt;
&lt;li&gt;创建一个全新的 images 。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两种方法各有优缺点。下面都来说一下怎么进行操作。&lt;/p&gt;

&lt;h2 id=&#34;way-one&#34;&gt;Way One&lt;/h2&gt;

&lt;p&gt;在已有的 images 中修改并 commit&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优点：

&lt;ul&gt;
&lt;li&gt;这是最方便快捷的方法&lt;/li&gt;
&lt;li&gt;可以避免自己打包而导致出现的一些问题，如静态文件引用错误等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点：

&lt;ul&gt;
&lt;li&gt;可定制程度低&lt;/li&gt;
&lt;li&gt;打包出来的镜像文件可能会很大，不利于存储&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 Docker 官网的文档中已经很详细操作过了，下面的是我翻译的版本。具体的官方英文&lt;a href=&#34;https://docs.docker.com/engine/tutorials/dockerimages/#/updating-and-committing-an-image&#34;&gt;点我&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先你需要一个 images 才能进行更新操作呀，所以首先：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#   获取 images
$ docker pull training/sinatra
#   运行 images 并进入到命令行中
$ docker run -t -i training/sinatra /bin/bash
root@0b2616b0e5a8:/#
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;记住这个被创建容器的 ID， &lt;code&gt;0b2616b0e5a8&lt;/code&gt; ，一会你会用得上的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接上面的操作&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#   首先更新一下 Ruby
root@0b2616b0e5a8:/# apt-get install -y ruby2.0-dev
#   然后安装  gem  json
root@0b2616b0e5a8:/# gem2.0 install json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成了这些更改之后，你可以运行 &lt;code&gt;exit&lt;/code&gt; 命令退出。&lt;/p&gt;

&lt;p&gt;现在你可以像使用 &lt;code&gt;git&lt;/code&gt; 一样更新这个镜像了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#   &#39;-m&#39; &#39;-a&#39; 这些看起来很熟悉啦，和 git 中是一样的，就不再说了...
$ docker commit -m &amp;quot;Added json gem&amp;quot; -a &amp;quot;Kate Smith&amp;quot; \
0b2616b0e5a8 ouruser/sinatra:v2

4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行一下 &lt;code&gt;docker images&lt;/code&gt; 来看看新创建的容器吧&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker images

REPOSITORY          TAG     IMAGE ID       CREATED       SIZE
training/sinatra    latest  5bc342fa0b91   10 hours ago  446.7 MB
ouruser/sinatra     v2      3c59e02ddd1a   10 hours ago  446.7 MB
ouruser/sinatra     latest  5db5f8471261   10 hours ago  446.7 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;way-two&#34;&gt;Way Two&lt;/h2&gt;

&lt;p&gt;完全创建一个新的 images 是很多人第一时间就想做的，但是官网简介中并没有太多详细标注的细节，那么我就以我的第一视角讲诉一下我是怎么创建一个全新的  images 的。&lt;/p&gt;

&lt;p&gt;依然是 Go ，首先创建一个简单的读取文件内容的项目：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd $GOPATH/src
$ mkdir File_Reader
$ vim File_Reader/main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	file, err := os.OpenFile(&amp;quot;./file.txt&amp;quot;, os.O_RDONLY, os.ModePerm)
	defer file.Close()

	if err != nil {
		log.Println(&amp;quot;file.txt open false!&amp;quot;)
	}

	fileReader := bufio.NewReader(file)

	for {
		line, err := fileReader.ReadString(&#39;\n&#39;)
		if err != nil {
			if err == io.EOF {
				break
			}
			log.Println(&amp;quot;Read File Content Failed!&amp;quot;, err.Error())
			return
		}
		fmt.Println(line)
	}

	fmt.Println(&amp;quot;File Read Done!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就是在当前目录下创建一个 &lt;code&gt;file.txt&lt;/code&gt; ，然后输入你想要的内容进去。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ &amp;quot;xxxxxx&amp;quot; &amp;gt;&amp;gt; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就需要先将源代码文件编译成二进制文件，因为如果我们希望这个 images 越小，越少的编译环境可以达到更好的效果。
命令如之前一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你可以看到当前目录下出现了一个 &lt;code&gt;main&lt;/code&gt; 的可执行文件。&lt;/p&gt;

&lt;p&gt;重要的步骤来了，当前目录下创建一个 &lt;code&gt;Dockerfile&lt;/code&gt; 文件，输入如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM scratch
MAINTAINER HackerZ
ADD main /
ADD file.txt /
CMD [&amp;quot;/main&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我来解释一下这些都是什么意思：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FROM : Docker 用来指定该镜像是基于哪个基础镜像构建的&lt;/li&gt;
&lt;li&gt;MAINTAINER : 镜像创建人的名字&lt;/li&gt;
&lt;li&gt;ADD  : 从 Dockerfile 所在目录拷贝文件到指定路径下&lt;/li&gt;
&lt;li&gt;CMD  : 用来指示当运行 &lt;code&gt;docker run&lt;/code&gt; 命令运行该镜像时要执行的命令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其余的还有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;EXPOSE : 开放的网络端口号&lt;/li&gt;
&lt;li&gt;ENV    : 设置环境变量&lt;/li&gt;
&lt;li&gt;VOLUME : 可以将本地文件夹或者其他容器的文件夹挂载到该容器中。&lt;/li&gt;
&lt;li&gt;WORKDIR: 切换目录用，可以多次切换(相当于cd命令)，对RUN,CMD,ENTRYPOINT生效&lt;/li&gt;
&lt;li&gt;ONBUILD: ONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了，运行 &lt;code&gt;docker build -t fileReader .&lt;/code&gt; 创建全新的 images 吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fun in Docker Day-1</title>
      <link>http://localhost/fun-in-docker-1/</link>
      <pubDate>Sat, 20 Aug 2016 16:17:42 +0800</pubDate>
      
      <guid>http://localhost/fun-in-docker-1/</guid>
      <description>

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;今天心血来潮，想在 OSX 中重新体验一下 &lt;code&gt;Docker&lt;/code&gt;，结果因为 &lt;code&gt;Docker&lt;/code&gt; 是基于 &lt;code&gt;Linux&lt;/code&gt;，在 OSX 中实在是 Fun 不起来，于是便纪录下来这天的过程。&lt;/p&gt;

&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;

&lt;p&gt;这部分没什么好说的， &lt;code&gt;Docker&lt;/code&gt; 官方已经出了 &lt;a href=&#34;https://docs.docker.com/docker-for-mac/&#34;&gt;OSX&lt;/a&gt; 的安装包，直接下载拖进 &lt;code&gt;Application/&lt;/code&gt; 即可完成安装。&lt;/p&gt;

&lt;p&gt;安装完成之后，可以直接在命令行中运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker --version  # Docker 主体
$ docker-compose --version  # 定义和管理复杂 Docker 应用的工具
$ docker-machine --version  # 简化 Docker 安装的工具
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看所有的安装工具是否能够正确启动。&lt;/p&gt;

&lt;p&gt;之后，便可以尝试运行 &lt;code&gt;Hello World&lt;/code&gt; 和 &lt;code&gt;nginx&lt;/code&gt; 玩一下了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Hello World
$ docker run hello-world

# nginx
$ docker run -d -p 80:80 --name webserver nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;package&#34;&gt;Package&lt;/h2&gt;

&lt;p&gt;以我的开源项目 &lt;a href=&#34;https://www.github.com/HackeZ/getMeizi&#34;&gt;getMeizi&lt;/a&gt; 为例子尝试打包 &lt;code&gt;Golang应用&lt;/code&gt; 。&lt;/p&gt;

&lt;h4 id=&#34;first-try&#34;&gt;First Try&lt;/h4&gt;

&lt;p&gt;首先我在项目的根目录下编写了一个 &lt;code&gt;Dockerfile&lt;/code&gt; 文件，其内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM golang:onbuild
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后通过 &lt;code&gt;$ docker build -t getmeizi .&lt;/code&gt; 来构建一个镜像。&lt;/p&gt;

&lt;p&gt;但是这样构建的镜像会将 &lt;code&gt;Golang&lt;/code&gt; 的整个环境都打包进去，生成的镜像大小为 &lt;code&gt;832.5 MB&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;很显然我们会更加愿意得到一个更灵活小巧的镜像，于是，我的目光转向了 &lt;code&gt;scratch&lt;/code&gt; 。&lt;/p&gt;

&lt;h4 id=&#34;second-try&#34;&gt;Second Try&lt;/h4&gt;

&lt;p&gt;修改 &lt;code&gt;Dockerfile&lt;/code&gt; 文件内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM scratch
ADD main /
CMD [&amp;quot;/main&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后先将 &lt;code&gt;getMeizi&lt;/code&gt; 应用编译完：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后使用 &lt;code&gt;$ docker build -t getmeizi .&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;构建即可生成一个仅有 &lt;code&gt;5.83 MB&lt;/code&gt; 大小的镜像。&lt;/p&gt;

&lt;h2 id=&#34;push&#34;&gt;Push&lt;/h2&gt;

&lt;p&gt;最后将打包好的镜像发布到 &lt;strong&gt;Docker.io&lt;/strong&gt; 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker images
# REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
# getmeizi            latest              7ddcbed63a17        2 minutes ago         5.839 MB

$ docker tag 7ddcbed63a17 hackerz/getmeizi

$ docker images
# REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
# getmeizi            latest              7ddcbed63a17        3 minutes ago         5.839 MB
# hackerz/getmeizi    latest              7ddcbed63a17        3 minutes ago         5.839 MB

$ docker login
# ***
# Login Succeeded

$ docker push hackerz/getmeizi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开 &lt;a href=&#34;https://hub.docker.com/r/hackerz/getmeizi/&#34;&gt;hackerz/getmeizi&lt;/a&gt; 查看并编辑镜像描述。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang Package Dependency Management Tool</title>
      <link>http://localhost/golang-package-dependency-management-tool/</link>
      <pubDate>Sun, 07 Aug 2016 11:11:25 +0800</pubDate>
      
      <guid>http://localhost/golang-package-dependency-management-tool/</guid>
      <description>

&lt;h1 id=&#34;golang-package-dependency-management-tool&#34;&gt;Golang Package Dependency Management Tool&lt;/h1&gt;

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Golang一直以来被外界诟病的一个问题就是包的依赖管理问题。那么今天就来讲一个：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Golang包依赖管理工具 —— gb&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;gb 在其官网中定义自己为：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A project based build tool for the Go programming language.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个Golang的项目工程通常由 &lt;code&gt;bin&lt;/code&gt;、&lt;code&gt;pkg&lt;/code&gt;、&lt;code&gt;src&lt;/code&gt;三个子目录构成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bin : 存放编译后生成的可执行文件&lt;/li&gt;
&lt;li&gt;pkg : 编译后生成的文件（如：.a）&lt;/li&gt;
&lt;li&gt;src : 存放源代码（如：.go .c .h .s等）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而 &lt;code&gt;gb&lt;/code&gt; 在这个概念的基础上新增了一个 &lt;code&gt;vendor&lt;/code&gt; 目录来存放项目依赖的第三方包（如 &lt;em&gt;beego&lt;/em&gt; ，&lt;em&gt;gracehttp&lt;/em&gt; 等）&lt;/p&gt;

&lt;h2 id=&#34;gb-action&#34;&gt;gb action&lt;/h2&gt;

&lt;h4 id=&#34;install&#34;&gt;Install&lt;/h4&gt;

&lt;p&gt;gb ==&amp;gt; &lt;a href=&#34;https://getgb.io/&#34;&gt;首页&lt;/a&gt;  ==&amp;gt;  &lt;a href=&#34;https://github.com/constabulary/gb/&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根据说明，使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go get github.com/constabulary/gb/...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令即可安装 gb。&lt;/p&gt;

&lt;p&gt;当该命令运行完毕，请检查 &lt;code&gt;env&lt;/code&gt; 下的第一个 &lt;code&gt;$GOPATH&lt;/code&gt; 的 &lt;code&gt;bin&lt;/code&gt; 目录下是否生成了 &lt;code&gt;gb&lt;/code&gt; 以及 &lt;code&gt;gb-vendor&lt;/code&gt; 两个可执行文件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如安装报错，请检查你是否正确配置了 $GOPATH 等环境变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;use&#34;&gt;Use&lt;/h4&gt;

&lt;p&gt;下面试着使用 &lt;code&gt;gb&lt;/code&gt; 来构建一个基于第三方包 &lt;code&gt;gracehttp&lt;/code&gt; 的简易 Golang Web 项目，来体验一下 &lt;code&gt;gb&lt;/code&gt; 的魅力。&lt;/p&gt;

&lt;p&gt;首先初始化 &lt;code&gt;hellogb&lt;/code&gt; 项目目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cd $GOPATH/src/hellogb
$ mkdir -p src/hellogb
$ mkdir -p vendor/src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写 Web 程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// vim src/hellogb/main.go
package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;

    &amp;quot;github.com/tabalt/gracehttp&amp;quot;
)

func main() {
    http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &amp;quot;hello gb&amp;quot;)
    })

    err := gracehttp.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;gb&lt;/code&gt; 添加依赖的 &lt;code&gt;gracehttp&lt;/code&gt; 第三方包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ gb vendor fetch github.com/tabalt/gracehttp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终整个项目目录结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./
|-- src
|   `-- hellogb
|       `-- main.go
`-- vendor
    |-- manifest
    `-- src
        `-- github.com
            `-- tabalt
                `-- gracehttp
                    |-- README.md
                    |-- connection.go
                    |-- gracehttpdemo
                    |   `-- main.go
                    |-- listener.go
                    `-- server.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译执行程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ gb build hellogb
$ ./bin/hellogb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后访问 &lt;code&gt;http://127.0.0.1:8080/&lt;/code&gt; 即可访问 Web 服务。&lt;/p&gt;

&lt;h4 id=&#34;command&#34;&gt;Command&lt;/h4&gt;

&lt;h5 id=&#34;gb-command&#34;&gt;gb Command&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Command&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;build&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;编译包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;vendor&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;调用 gb-vendor&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;doc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;显示文档&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;env&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;打印项目的环境变量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;generate&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;处理源代码生成Go文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;info&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;显示项目的信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;显示项目下的所有包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;test&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;执行测试&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;gb-vendor-parameter&#34;&gt;gb vendor Parameter&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;fetch&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;获取一个远程依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;update&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;更新一个本地依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;每行一个列出所有依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;delete&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;删除一个本地依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;purge&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;清除所有未引用的依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;restore&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;从manifest清单文件还原依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;本文参考 tabalt 的 &lt;a href=&#34;http://tabalt.net/blog/golang-package-dependency-management-tool-gb/&#34;&gt;Golang包依赖管理工具gb&lt;/a&gt; 一文。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>redigo : open too many files</title>
      <link>http://localhost/redigo-open2manyfiles/</link>
      <pubDate>Wed, 27 Jul 2016 13:29:11 +0800</pubDate>
      
      <guid>http://localhost/redigo-open2manyfiles/</guid>
      <description>

&lt;h1 id=&#34;redigo-panic-error-open-too-many-files&#34;&gt;Redigo - panic error : open too many files.&lt;/h1&gt;

&lt;h3 id=&#34;abstract&#34;&gt;Abstract&lt;/h3&gt;

&lt;p&gt;今天对 &lt;a href=&#34;https://www.github.com/HackeZ/getAcFunPage&#34;&gt;getAcFunPage&lt;/a&gt; 项目做 Benchmark 的时候发现了 Redis 会频繁报一个 &lt;code&gt;socket: too many open files&lt;/code&gt; 的错误，后来发现并不是代码的问题，而是 Linux 的设置问题。
下面就来说说我是这么解决这个问题的。&lt;/p&gt;

&lt;h3 id=&#34;problem&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Benchmark 时报错内容截取如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http: panic serving 127.0.0.1:53512: dial tcp :6379: socket: too many open files
goroutine 5322 [running]:
net/http.(*conn).serve.func1(0xc820f87f80)
    /usr/local/go/src/net/http/server.go:1389 +0xc1
panic(0x797240, 0xc820b12050)
    /usr/local/go/src/runtime/panic.go:426 +0x4e9
main.GetPageAndJSON(0x0, 0x0)
    /home/hackerzgz/workspace/golang/src/getAcFunPage/main.go:130 +0x20a
main.HandleGetResp(0x7f2103407500, 0xc8212fb450, 0xc8210a68c0)
    /home/hackerzgz/workspace/golang/src/getAcFunPage/main.go:82 +0x18
net/http.HandlerFunc.ServeHTTP(0x8902f0, 0x7f2103407500, 0xc8212fb450, 0xc8210a68c0)
    /usr/local/go/src/net/http/server.go:1618 +0x3a
net/http.(*ServeMux).ServeHTTP(0xc820015740, 0x7f2103407500, 0xc8212fb450, 0xc8210a68c0)
    /usr/local/go/src/net/http/server.go:1910 +0x17d
net/http.serverHandler.ServeHTTP(0xc82008a680, 0x7f2103407500, 0xc8212fb450, 0xc8210a68c0)
    /usr/local/go/src/net/http/server.go:2081 +0x19e
net/http.(*conn).serve(0xc820f87f80)
    /usr/local/go/src/net/http/server.go:1472 +0xf2e
created by net/http.(*Server).Serve
    /usr/local/go/src/net/http/server.go:2137 +0x44e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现这个错误的时候， &lt;code&gt;webbench&lt;/code&gt; 的参数为 &lt;code&gt;-c 300 -t 60&lt;/code&gt; ，也就是并发300个客户端访问并持续60s。&lt;/p&gt;

&lt;p&gt;由报错信息第一行中的 &lt;code&gt;dial tcp :6379&lt;/code&gt; 很容易看出，这是由 Redis 所引起的错误。&lt;/p&gt;

&lt;h3 id=&#34;why&#34;&gt;Why&lt;/h3&gt;

&lt;p&gt;根据 &lt;a href=&#34;http://stackoverflow.com/questions/19971968/go-golang-redis-too-many-open-files-error&#34;&gt;Stack Overflow&lt;/a&gt; 上的一个回答，这是由于 Linux 下设置的 &lt;strong&gt;文件描述符上限(file descriptors limit)&lt;/strong&gt; 所引起的错误，在Ubuntu系统中，该值上限为 &lt;strong&gt;1024&lt;/strong&gt; ，于是当 Redis 需要接收来自高并发所带来的连接请求时，连接数很有可能 &lt;strong&gt;超出文件描述符的上限值&lt;/strong&gt; ，于是 Redis 就会报错了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文件描述符:&lt;br /&gt;
内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;solve&#34;&gt;Solve&lt;/h3&gt;

&lt;p&gt;要解决这个问题也很简单，只需要将服务器系统的文件描述符上限修改成一个更大的值即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ulimit -n 99999
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后还需要对 Redigo 的连接池设置做出修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;return &amp;amp;redis.Pool{
		MaxIdle:     64,
		IdleTimeout: 3 * time.Second,
		MaxActive:   99999, // max number of connections
		...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译，测试。终于不再报错了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why HandleFunc Called Twice</title>
      <link>http://localhost/why-handlefunc-called-twice/</link>
      <pubDate>Sun, 24 Jul 2016 20:03:59 +0800</pubDate>
      
      <guid>http://localhost/why-handlefunc-called-twice/</guid>
      <description>

&lt;h2 id=&#34;why-handlefunc-called-twice&#34;&gt;Why &lt;strong&gt;HandleFunc()&lt;/strong&gt; called twice?&lt;/h2&gt;

&lt;h3 id=&#34;abstract&#34;&gt;Abstract&lt;/h3&gt;

&lt;p&gt;今天遇到之前碰见过的一个问题，但是之前忘记研究了，正好今天终于把这个问题弄清楚了，于是记录下来。&lt;/p&gt;

&lt;p&gt;想必很多做后台的小伙伴都写过服务器了，但是有没有遇到服务器在 &lt;strong&gt;通过不同的（Brower、API）方式访问&lt;/strong&gt; 的时候，服务器响应方法的 &lt;strong&gt;次数&lt;/strong&gt; 是不一样的情况呢？&lt;/p&gt;

&lt;h3 id=&#34;problem&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;先来看看Golang中的简易服务器搭建代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func SayHello(rw http.ResponseWriter, req *http.Request) {
    io.WriteString(rw, &amp;quot;hello~ You are in!&amp;quot;)
    log.Println(&amp;quot;Oh, Here is a Guy coming in!&amp;quot;)
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc(&amp;quot;/&amp;quot;, SayHello)
    http.ListenAndServe(&amp;quot;:8080&amp;quot;, mux)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个最简单的Golang服务器搭建，当http访问 &lt;code&gt;http://localhost:8080&lt;/code&gt; 的时候，该服务器会对客户端返回 &lt;code&gt;hello~ You are in!&lt;/code&gt; ，同时在服务器控制台中打印 &lt;code&gt;Oh, Here is a Guy coming in!&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;有意思的部分来了：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;通过 &lt;strong&gt;Brower&lt;/strong&gt; 访问的时候，服务器控制台会打印出 &lt;strong&gt;两行&lt;/strong&gt; &lt;code&gt;Oh, Here is a Guy coming in!&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;curl http://localhost:8080&lt;/code&gt; 命令进行访问的时候，服务器控制台只会打印 &lt;strong&gt;一行&lt;/strong&gt; &lt;code&gt;Oh, Here is a Guy coming in!&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;why&#34;&gt;Why&lt;/h2&gt;

&lt;p&gt;为什么会出现那么有趣的问题呢？&lt;a href=&#34;http://stackoverflow.com/questions/33432192/handlefunc-being-called-twice&#34;&gt;StackOver&lt;/a&gt;上也有人问了这个问题，原因出现在 Brower 上，通过打印 &lt;code&gt;requsets&lt;/code&gt;，你会发现 Brower 还会发起二次请求去请求 &lt;code&gt;/favicon.ico&lt;/code&gt;，也就是页面的小图标。&lt;/p&gt;

&lt;p&gt;所以这就是用 &lt;code&gt;CURL&lt;/code&gt; 发起请求的时候，并不会出现二次请求的原因！&lt;/p&gt;

&lt;h2 id=&#34;solve&#34;&gt;Solve&lt;/h2&gt;

&lt;p&gt;既然知道了这个问题出现在哪，剩下就好办了，既然浏览器要请求图标，那么我们就在写一个路由专门处理这个请求即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    mux := http.NewServeMux()
    mux.HandleFunc(&amp;quot;/&amp;quot;, SayHello)
    // Handle /favicon.ico
    mux.HandleFunc(&amp;quot;/favicon.ico&amp;quot;, func(rw http.ResponseWriter, req *http.Request) {})
    http.ListenAndServe(&amp;quot;:9000&amp;quot;, mux)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang Dev Log</title>
      <link>http://localhost/golang-dev-log/</link>
      <pubDate>Sat, 23 Jul 2016 16:34:45 +0800</pubDate>
      
      <guid>http://localhost/golang-dev-log/</guid>
      <description>

&lt;h2 id=&#34;golang-dev-log&#34;&gt;Golang Dev Log&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;今天快要把 &lt;a href=&#34;https://www.github.com/HackeZ/getAcFunPage&#34;&gt;getAcFunPage&lt;/a&gt; 这个项目完结了，结果在重构项目的时候出现了两个哭笑不得的 &lt;strong&gt;BUG&lt;/strong&gt; 。总结下来，都是因为自身对 Golang 认识不够深入而出现的问题，所以现在这篇 Blog 是专门记录我在Golang开发中遇到的需要注意的点，以此警醒自己！&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个通用的结构体应该以一个包的方式存在并进行引用，否则会出现同一个结构体在不同的包中声明之后，在调用的时候，编译器会报 &lt;code&gt;cannot use xxx (type user) as type School.user&lt;/code&gt; 的错误。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Example 1

// file main.go
type user struct {
    name     string
    age      int64
}

// file school.go
type user struct {
    name     string
    age      int64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;如果一个函数需要使用一个 &lt;strong&gt;相对路径&lt;/strong&gt; 调用一个 &lt;code&gt;静态文件&lt;/code&gt; ，那么需要将这个 &lt;code&gt;静态文件&lt;/code&gt; 的路径作为参数进行传入。&lt;br /&gt;
因为 Golang 中对于 &lt;code&gt;静态文件&lt;/code&gt; 的调用不是根据函数所在位置的 &lt;strong&gt;相对路径&lt;/strong&gt; ，而是取决于调用这个函数的文件的位置所对应的相对路径。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Example 2

// ./markdown/markdown-style.go (Wrong)
func GetStyle() {
    f, err := os.OpenFile(&amp;quot;./markdown-style.css&amp;quot;,...)
}

// ./markdown/markdown-style.go (Corrent)
func GetStyle(filepath string) {
    f, err := os.OpenFile(filepath,...)
}

// ./main.go
func main() {
    // Wrong:  The system cannot find the file specified.
    md.GetStyle()

    // Corrent
    md.Corrent(&amp;quot;./markdown/markdown-style.css&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Redigo Action - 1</title>
      <link>http://localhost/redigo-action-1/</link>
      <pubDate>Fri, 22 Jul 2016 10:41:10 +0800</pubDate>
      
      <guid>http://localhost/redigo-action-1/</guid>
      <description>

&lt;h1 id=&#34;redigo-action&#34;&gt;Redigo Action&lt;/h1&gt;

&lt;h4 id=&#34;redis-作为一个内存型的高性能数据库-如今是越来越火了-为了得到更高的-qps-以及-tps-我们无法忽视掉这个如此强大的数据库&#34;&gt;Redis 作为一个内存型的高性能数据库，如今是越来越火了，为了得到更高的 QPS 以及 TPS ，我们无法忽视掉这个如此强大的数据库。&lt;/h4&gt;

&lt;h4 id=&#34;在-redis-官网中-golang语言的-框架-http-redis-io-clients-go-有两个是被官方所推荐的-分别为&#34;&gt;在 Redis 官网中，Golang语言的&lt;a href=&#34;http:redis.io/clients#go&#34;&gt;框架&lt;/a&gt;有两个是被官方所推荐的，分别为：&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1. &lt;a href=&#34;https:github.com/garyburd/redigo&#34;&gt;Redigo&lt;/a&gt;&lt;/strong&gt;
&lt;strong&gt;2. &lt;a href=&#34;https:github.com/mediocregopher/radix.v2&#34;&gt;Radix&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;本着源码易读优先-我选择了-redigo-进行开发尝试-项目地址-点我-https-www-github-com-hackez-getacfunpage&#34;&gt;本着源码易读优先，我选择了 Redigo 进行开发尝试，项目地址&lt;a href=&#34;https:www.github.com/HackeZ/getAcFunPage&#34;&gt;点我&lt;/a&gt;。&lt;/h4&gt;

&lt;h3 id=&#34;action&#34;&gt;Action&lt;/h3&gt;

&lt;p&gt;熟悉Redis的同学都知道，Redis是 &lt;strong&gt;单进程，单线程，IO多路复用&lt;/strong&gt; 的，这一点不同于 MySQL 的多线程。
 这就意味这Redis可以使用长连接来进行通信，那么，我们就需要一个连接池去管理这些长连接，当一个长连接使用完毕之后就可以交给下一个长连接继续进行使用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;连接池&lt;/strong&gt;
基本思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。
而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。
也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而 Redigo 就是支持连接池的，看看 &lt;a href=&#34;https:github.com/garyburd/redigo/blob/master/redis/pool.go#L43&#34;&gt;Redigo - Pool&lt;/a&gt;.
其 L43 ～ L92 就给出了一个完整的 连接池 的正确打开方式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func newPool(server, password string) *redis.Pool {
      return &amp;amp;redis.Pool{
          MaxIdle: 3,
          IdleTimeout: 240 * time.Second,
          Dial: func () (redis.Conn, error) {
            c, err := redis.Dial(&amp;quot;tcp&amp;quot;, server)
            if err != nil {
                return nil, err
            }
            if _, err := c.Do(&amp;quot;AUTH&amp;quot;, password); err != nil {
                c.Close()
                return nil, err
              }
               return c, err
          },
          TestOnBorrow: func(c redis.Conn, t time.Time) error {
              _, err := c.Do(&amp;quot;PING&amp;quot;)
              return err
          },
      }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段简单易懂的代码返回了一个可用的 Redis 连接池，为了能够进行长连接处理，我们还需要定义一个全局的 &lt;strong&gt;redis.Pool&lt;/strong&gt; 变量进行使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  var (
      pool *redis.Pool
      redisServer = flag.String(&amp;quot;redisServer&amp;quot;, &amp;quot;:6379&amp;quot;, &amp;quot;&amp;quot;)
      redisPassword = flag.String(&amp;quot;redisPassword&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;)
  )

  func main() {
      flag.Parse()
      pool = newPool(*redisServer, *redisPassword)
      ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 &lt;strong&gt;request请求&lt;/strong&gt; 来到，我们就可以这样进行获取连接，并且一定记得在使用完毕之后将连接放回连接池。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;   func serveHome(w http.ResponseWriter, r *http.Request) {
       conn := pool.Get()
       defer conn.Close()
       ....
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;到了这里-一个可用并且高性能的-redis-数据库的连接已经基本构建完毕了&#34;&gt;到了这里，一个可用并且高性能的 Redis 数据库的连接已经基本构建完毕了！&lt;/h5&gt;

&lt;h5 id=&#34;接下来就可以愉快地进行使用了&#34;&gt;接下来就可以愉快地进行使用了～&lt;/h5&gt;
</description>
    </item>
    
    <item>
      <title>Learning in Hadoop - Day 1</title>
      <link>http://localhost/hadoop-1/</link>
      <pubDate>Mon, 13 Jun 2016 20:45:25 +0800</pubDate>
      
      <guid>http://localhost/hadoop-1/</guid>
      <description>&lt;p&gt;第一次玩Hadoop&lt;/p&gt;

&lt;p&gt;最近在折腾机器学习，因为查阅到Yahoo的&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;《Predicting The Next App That You Are Going To Use》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这一篇Paper的时候，它提到了Google的 &lt;strong&gt;MapReduce&lt;/strong&gt;以及 &lt;strong&gt;Word2Vec&lt;/strong&gt; 。相信折腾过机器学习的小伙伴都会比较熟悉这两个东西了。于是，为了更深入地进行学习，我便无情地掉进了这个 &lt;strong&gt;坑&lt;/strong&gt; 里。&lt;/p&gt;

&lt;p&gt;首先介绍一下背景，Yahoo的这篇Paper主要就是根据用户日常APP的使用习惯，然后对用户下一启动的APP进行预测。因为Yahoo认为日常手机的使用场景会对哪个APP的开启与否有着很强的关联性，于是他们便使用了 &lt;strong&gt;Word2Vec&lt;/strong&gt; 对用户手机中记录的6个手机事件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Last Location Update&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Last Charge Cavle&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Last Audio Cable&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Last Context Trigger&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Last Context Pulled&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Last App Open&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进行计算词向量，用于文本预测。而Word2Vec有着3个广为流传的版本：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是这3个版本对于Yahoo来说性能都是不足的，经我测试，一个800M的文本在C语言版本中计算时间需要20Min！&lt;/p&gt;

&lt;p&gt;而在预测下一个APP这个场景里，这种计算速度是完全不可以接受的，于是Yahoo他们利用MapReduce重写了一个Word2Vec，将这个版本放在云端进行计算。这就是我进行MapReduce学习的原因。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Named Question in Golang</title>
      <link>http://localhost/lenproblem/</link>
      <pubDate>Thu, 02 Jun 2016 11:08:54 +0800</pubDate>
      
      <guid>http://localhost/lenproblem/</guid>
      <description>&lt;p&gt;Golang中遇到的命名问题&lt;/p&gt;

&lt;p&gt;昨天在写随机生成字符串代码时候遇到了一个Golang的命名问题，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GetRandomString(len string) string {
    str := &amp;quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot;
    bytes := []byte(str)
    result := []byte{}
    r := rand.New(rand.NewSource(time.Now().UnixNano()))

    for i := 0; i &amp;lt; len; i++ {
        result = append(result, bytes[r.Intn(len(str))]) // &amp;lt;- Here is the Problem: `cannot call non-function len (type int)`
    }
    return string(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个问题太蛋疼了，之前好像从来没遇到过这个问题，而且Google好像也没有找到相关的问题原因。&lt;/p&gt;

&lt;p&gt;后来一步步排查代码，才发现问题原来是出现在：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;for i := 0; i &amp;lt; &lt;strong&gt;len&lt;/strong&gt;; i++ {&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;中的 &lt;strong&gt;len&lt;/strong&gt; 变量与函数 &lt;strong&gt;len()&lt;/strong&gt; 重复而出现的命名错误，所以只需要将 &lt;strong&gt;len&lt;/strong&gt; 变量重新命名即可解决该问题。&lt;/p&gt;

&lt;p&gt;总结：在Golang中使用的变量一定不要和某个函数名字相同，否则不会通过，我现在暂时不清楚是Golang编译器出现的问题，还是Golang本来就不允许这样写，我会继续查阅相关文档查清楚！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>